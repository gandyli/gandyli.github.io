<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>andyli的博客</title>
  
  <subtitle>做最好的自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gandyli.xyz/"/>
  <updated>2019-06-24T16:11:52.843Z</updated>
  <id>https://gandyli.xyz/</id>
  
  <author>
    <name>andyli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>题解 UVA11090 【Going in Cycle!!】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA11090-%E3%80%90Going-in-Cycle-%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA11090-【Going-in-Cycle-】/</id>
    <published>2019-06-24T16:10:57.000Z</published>
    <updated>2019-06-24T16:11:52.843Z</updated>
    
    <content type="html"><![CDATA[<p>使用二分法求解。对于一个猜测值$M$，只需要判断是否存在平均值小于$M$的回路。如何判断呢？假设存在一个包含$k$条边的回路，回路上各条边的权值为$w_1,w_2,…,w_k$，那么平均值小于$M$意味着$w_1+w_2+…+w_k&lt;k*mid$即：<br>$$(w_1-M)+(w_2-M)+(w_3-M)+…+(w_k-M)&lt;0$$<br>换句话说，只要把每条边$(a,b)$的权值$w(a,b)$变成$w(a,b)-M$，再判断新图中是否有负环即可。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">51</span>, maxm = <span class="number">2501</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>, <span class="keyword">double</span> w = <span class="number">0.0</span>) : next(next), to(to), w(w) &#123;&#125;</span><br><span class="line">&#125; edges[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], inqcnt[maxn], n, m, cnt;</span><br><span class="line"><span class="keyword">double</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges[++cnt] = Edge(head[u], v, w);</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(inqcnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(inqcnt));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dis[i] = <span class="number">0</span>, q.push(i);</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edges[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">            <span class="keyword">double</span> t = dis[u] + edges[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; t)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = t;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (++inqcnt[v] &gt; n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        edges[i].w -= x; <span class="comment">// 修改权值</span></span><br><span class="line">    <span class="keyword">bool</span> ans = SPFA();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        edges[i].w += x; <span class="comment">// 恢复权值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= T; kase++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> L = <span class="number">0.0</span>, R = <span class="number">0</span>; <span class="comment">// R为最大权值</span></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            R = max(R, w * <span class="number">1.0</span>);</span><br><span class="line">            AddEdge(u, v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>, kase);</span><br><span class="line">        <span class="keyword">if</span> (!test(R + <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No cycle found.\n"</span>); <span class="comment">// 如果有负环，平均权值一定小于R+1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (R - L &gt; <span class="number">1e-3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (test(M))</span><br><span class="line">                    R = M;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    L = M;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, L);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用二分法求解。对于一个猜测值$M$，只需要判断是否存在平均值小于$M$的回路。如何判断呢？假设存在一个包含$k$条边的回路，回路上各条边的权值为$w_1,w_2,…,w_k$，那么平均值小于$M$意味着$w_1+w_2+…+w_k&amp;lt;k*mid$即：&lt;br&gt;$$(w_
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA11374 【Airport Express】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA11374-%E3%80%90Airport-Express%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA11374-【Airport-Express】/</id>
    <published>2019-06-24T16:10:23.000Z</published>
    <updated>2019-06-24T16:10:37.630Z</updated>
    
    <content type="html"><![CDATA[<p>因为商业线只能坐一站，所以可以枚举坐的是哪一站，比较所有可能性下的最优解。如果可以在$O(1)$的时间内计算出每种方案对应的最优方案，整个问题就可以在$O(K)$的时间内得到解决。<br>假设我们用商业线车票从车站$a$坐到车站$b$，则从起点到$a$、从$a$到终点这两部分路线对于“经济线网络”来说都应该是最短路。换句话说，我们只需要从起点开始、到终点结束坐两次单源最短路，记录下从起点到每一个点$x$的最短时间$f(x)$和从每个点$x$到终点的最短时间$g(x)$，则总时间为$f(a)+T(a,b)+g(b)$，其中$T(a,b)$为从$a$坐一站商业线到达$b$的时间。<br>算上预处理时间$O(m\log n)$，本算法的总时间复杂度为$O(m\log n+k)$。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>, maxn = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, dist;</span><br><span class="line">    Edge() &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d) : next(u), to(v), dist(d) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> d, u;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> HeapNode &amp;rhs) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> d &gt; rhs.d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">bool</span> done[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn], head[maxn];</span><br><span class="line">    <span class="keyword">int</span> p[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        edges.clear();</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dist)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.emplace_back(head[from], to, dist);</span><br><span class="line">        head[from] = edges.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        priority_queue&lt;HeapNode&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            d[i] = INF;</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(done, <span class="number">0</span>, <span class="keyword">sizeof</span>(done));</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">        Q.push((HeapNode)&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            HeapNode x = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">int</span> u = x.u;</span><br><span class="line">            <span class="keyword">if</span> (done[u])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            done[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = head[u]; ~v; v = edges[v].next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[edges[v].to] &gt; d[u] + edges[v].dist)</span><br><span class="line">                &#123;</span><br><span class="line">                    d[edges[v].to] = d[u] + edges[v].dist;</span><br><span class="line">                    p[edges[v].to] = u;</span><br><span class="line">                    Q.push((HeapNode)&#123;d[edges[v].to], edges[v].to&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> diss[maxn], ps[maxn], cnt;</span><br><span class="line">Edge edges[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, S, E, M, kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;S, &amp;E) == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (kase++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        Dijkstra dij;</span><br><span class="line">        dij.init(N);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M);</span><br><span class="line">        <span class="keyword">while</span> (M--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            dij.AddEdge(u, v, w);</span><br><span class="line">            dij.AddEdge(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edges[++cnt] = Edge(u, v, w);</span><br><span class="line">            edges[++cnt] = Edge(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        dij.dijkstra(S);</span><br><span class="line">        <span class="built_in">memcpy</span>(diss, dij.d, <span class="keyword">sizeof</span>(dij.d));</span><br><span class="line">        <span class="built_in">memcpy</span>(ps, dij.p, <span class="keyword">sizeof</span>(dij.p));</span><br><span class="line">        dij.dijkstra(E);</span><br><span class="line">        <span class="keyword">int</span> maxt = diss[E], used = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">            <span class="keyword">if</span> (maxt &gt; diss[edges[i].next] + edges[i].dist + dij.d[edges[i].to])</span><br><span class="line">                maxt = diss[edges[i].next] + edges[i].dist + dij.d[edges[i].to], used = i;</span><br><span class="line">        <span class="keyword">if</span> (used)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">            <span class="keyword">int</span> u = edges[used].next;</span><br><span class="line">            <span class="keyword">while</span> (u)</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(u);</span><br><span class="line">                u = ps[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!st.empty())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, st.top()), st.pop();</span><br><span class="line">            u = edges[used].to;</span><br><span class="line">            <span class="keyword">while</span> (u != E)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">                u = dij.p[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n%d\n%d\n"</span>, E, edges[used].next, maxt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = S;</span><br><span class="line">            <span class="keyword">while</span> (u != E)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">                u = dij.p[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\nTicket Not Used\n%d\n"</span>, E, maxt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为商业线只能坐一站，所以可以枚举坐的是哪一站，比较所有可能性下的最优解。如果可以在$O(1)$的时间内计算出每种方案对应的最优方案，整个问题就可以在$O(K)$的时间内得到解决。&lt;br&gt;假设我们用商业线车票从车站$a$坐到车站$b$，则从起点到$a$、从$a$到终点这两部
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA10047 【The Monocycle】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA10047-%E3%80%90The-Monocycle%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA10047-【The-Monocycle】/</id>
    <published>2019-06-24T16:08:39.000Z</published>
    <updated>2019-06-24T16:08:55.343Z</updated>
    
    <content type="html"><![CDATA[<p>本题看上去也是一个最短路问题，但似乎有一些特殊：到达同一个格子时，自行车可能处于不同的“状态”，因为朝向可能不同，接触地面的扇形颜色可能会不同。这样，我们把这两个附加因素纳入到考虑范围内，把每个$(x,y,d,c)$作为一个结点，表示自行车当前位置在格子$(x,y)$，朝向为$d$，底面颜色为$c$，一共有$20MN$个结点。从每个结点出发最多有$3$条边（分别对应前进、左转和右转），因此有不超过$60MN$条边的情况，完全可以承受。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>, maxn = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> maze[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn][<span class="number">4</span>][<span class="number">5</span>], vis[maxn][maxn][<span class="number">4</span>][<span class="number">5</span>], ans;</span><br><span class="line"><span class="keyword">int</span> R, C, sr, sc, tr, tc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> r, c, dir, color;</span><br><span class="line">    Point(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> dir, <span class="keyword">int</span> color) : r(r), c(c), dir(dir), color(color) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;Point&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> dir, <span class="keyword">int</span> color, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= R || c &lt; <span class="number">0</span> || c &gt;= C)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (maze[r][c] == <span class="string">'.'</span> &amp;&amp; !vis[r][c][dir][color])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//q.push(Point(r, c, dir, color));</span></span><br><span class="line">        q.emplace(r, c, dir, color);</span><br><span class="line">        vis[r][c][dir][color] = <span class="number">1</span>;</span><br><span class="line">        d[r][c][dir][color] = v;</span><br><span class="line">        <span class="keyword">if</span> (r == tr &amp;&amp; c == tc &amp;&amp; !color)</span><br><span class="line">            ans = min(ans, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Point st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[st.r][st.c][st.dir][st.color] = <span class="number">0</span>;</span><br><span class="line">    vis[st.r][st.c][st.dir][st.color] = <span class="number">1</span>;</span><br><span class="line">    q.push(st);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        st = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> v = d[st.r][st.c][st.dir][st.color] + <span class="number">1</span>;</span><br><span class="line">        update(st.r, st.c, (st.dir + <span class="number">1</span>) % <span class="number">4</span>, st.color, v);</span><br><span class="line">        update(st.r, st.c, (st.dir + <span class="number">3</span>) % <span class="number">4</span>, st.color, v);</span><br><span class="line">        update(st.r + dr[st.dir], st.c + dc[st.dir], st.dir, (st.color + <span class="number">1</span>) % <span class="number">5</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;R, &amp;C) &amp;&amp; R &amp;&amp; C)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, maze[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++)</span><br><span class="line">                <span class="keyword">if</span> (maze[i][j] == <span class="string">'S'</span>)</span><br><span class="line">                    sr = i, sc = j;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (maze[i][j] == <span class="string">'T'</span>)</span><br><span class="line">                    tr = i, tc = j;</span><br><span class="line">        &#125;</span><br><span class="line">        maze[sr][sc] = maze[tr][tc] = <span class="string">'.'</span>;</span><br><span class="line">        ans = INF;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        bfs(Point(sr, sc, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (kase)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d\n"</span>, ++kase);</span><br><span class="line">        <span class="keyword">if</span> (ans == INF)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"destination not reachable\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"minimum time = %d sec\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题看上去也是一个最短路问题，但似乎有一些特殊：到达同一个格子时，自行车可能处于不同的“状态”，因为朝向可能不同，接触地面的扇形颜色可能会不同。这样，我们把这两个附加因素纳入到考虑范围内，把每个$(x,y,d,c)$作为一个结点，表示自行车当前位置在格子$(x,y)$，朝向
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA11624 【Fire!】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA11624-%E3%80%90Fire-%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA11624-【Fire-】/</id>
    <published>2019-06-24T16:07:45.000Z</published>
    <updated>2019-06-24T16:08:18.395Z</updated>
    
    <content type="html"><![CDATA[<p>如果没有火，那么本题是一个标准的迷宫问题，可以用$BFS$解决。加上了火，难度增加了多少呢 ？其实没多少。注意，火是不会自动熄灭的，因此只要某个格子在某时刻起火了，以后将一直如此。所以只需要预处理每个格子起火的时间，在$BFS$扩展结点的时候加一个条件判断，当到达新结点时该格子没着火才真的把这个新结点加到队列中。<br>最后需要考虑一下如何求出每个格子起火的时间，其实这也是个最短路问题，只不过起点不是一个，而是多个（所有初始的着火点）。这只需要在初始化队列时把所有着火点都放进去即可。<br>两个步骤的时间复杂度均为$O(RC)$。<br>去除模板后代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dir[][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;, maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> A[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> t[maxn][maxn], vis[maxn][maxn], r, c, bx, by;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="built_in">queue</span>&lt;pii&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isvaild</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; r &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> (*pArr)[<span class="number">1005</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fr = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (pArr == vis &amp;&amp; (!fr.first || !fr.second || fr.first == r - <span class="number">1</span> || fr.second == c - <span class="number">1</span>))            <span class="keyword">return</span> pArr[fr.first][fr.second];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = fr.first + dir[i][<span class="number">0</span>], ny = fr.second + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isvaild(nx, ny) &amp;&amp; pArr[nx][ny] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pArr == vis &amp;&amp; pArr[fr.first][fr.second] + <span class="number">1</span> &gt;= t[nx][ny] &amp;&amp; t[nx][ny] != <span class="number">-1</span>) || A[nx][ny] == <span class="string">'#'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                pArr[nx][ny] = pArr[fr.first][fr.second] + <span class="number">1</span>;</span><br><span class="line">                q.push(pii(nx, ny));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">            q.pop();</span><br><span class="line">        read(r, c);</span><br><span class="line">        <span class="built_in">memset</span>(t, <span class="number">-1</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line">                <span class="keyword">if</span> ((A[i][j] = getchigws()) == <span class="string">'F'</span>)</span><br><span class="line">                    q.push(pii(i, j)), A[i][j] = <span class="string">'.'</span>, t[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (A[i][j] == <span class="string">'J'</span>)</span><br><span class="line">                    bx = i, by = j, A[i][j] = <span class="string">'.'</span>;</span><br><span class="line">        bfs(t);</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        q.push(pii(bx, by));</span><br><span class="line">        vis[bx][by] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = bfs(vis);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>)</span><br><span class="line">            writeln(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            writeln(ans + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果没有火，那么本题是一个标准的迷宫问题，可以用$BFS$解决。加上了火，难度增加了多少呢 ？其实没多少。注意，火是不会自动熄灭的，因此只要某个格子在某时刻起火了，以后将一直如此。所以只需要预处理每个格子起火的时间，在$BFS$扩展结点的时候加一个条件判断，当到达新结点时该
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1416 【Warfare And Logistics】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1416-%E3%80%90Warfare-And-Logistics%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1416-【Warfare-And-Logistics】/</id>
    <published>2019-06-24T16:07:01.000Z</published>
    <updated>2019-06-24T16:07:20.201Z</updated>
    
    <content type="html"><![CDATA[<p>如果用$floyd$算法计算$c$，每尝试着删除一条边都要重新计算一次，时间复杂度为$O(n^3m)$，很难承受。如果用$n$次$Dijkstra$计算单源最短路，时间复杂度为$O(nm^2\log n)$。虽然看上去比$O(n^3m)$略好，但由于$floyd$算法的常数很小，实际运行时间差不多。这时候，最短路树派上用场了。因为在源点确定的情况下，只要最短路树不被破坏，起点到所有点的距离都不会发生改变。换句话说，只有删除最短路树上的$n-1$条边，最短路树才需要重新计算。这样，对于每个源点，最短只需要求n次而不是$m$次单源最短路，时间复杂度降为$O(n^2m\log n)$，可以承受。另外，本题有一个不容易发现的“陷阱”：如果有重边，删除一条边时2，应该用第二短的边代替。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>, maxn = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : u(u), v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, u;</span><br><span class="line">    HeapNode(<span class="keyword">int</span> d = <span class="number">0</span>, <span class="keyword">int</span> u = <span class="number">0</span>) : d(d), u(u) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> HeapNode&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> d &gt; rhs.d; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dijkstra</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];  <span class="comment">// 是否已永久标号</span></span><br><span class="line">    <span class="keyword">int</span> d[maxn];     <span class="comment">// s到各个点的距离</span></span><br><span class="line">    <span class="keyword">int</span> p[maxn];     <span class="comment">// 最短路中的上一条弧</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.emplace_back(u, v, w);</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[u].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        priority_queue&lt;HeapNode&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            d[i] = INF;</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        q.emplace(<span class="number">0</span>, s);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            HeapNode x = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> u = x.u;</span><br><span class="line">            <span class="keyword">if</span> (vis[u])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vis[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.w &gt; <span class="number">0</span> &amp;&amp; d[e.v] &gt; d[u] + e.w)</span><br><span class="line">                &#123;  <span class="comment">// 此处和模板不同，忽略了dist=-1的边。此为删除标记。根据题意和dijkstra算法的前提，正常的边dist&gt;0</span></span><br><span class="line">                    d[e.v] = d[u] + e.w;</span><br><span class="line">                    p[e.v] = G[u][i];</span><br><span class="line">                    q.emplace(d[e.v], e.v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dijkstra solver;</span><br><span class="line"><span class="keyword">int</span> n, m, L;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gr[maxn][maxn];  <span class="comment">// 两点之间的原始边权</span></span><br><span class="line"><span class="keyword">bool</span> used[maxn][maxn][maxn];  <span class="comment">// used[src][a][b]表示源点为src的最短路树是否包含边a-&gt;b</span></span><br><span class="line"><span class="keyword">int</span> idx[maxn][maxn];  <span class="comment">// idx[u][v]为边u-&gt;v在Dijkstra求解器中的编号</span></span><br><span class="line"><span class="keyword">int</span> sum_single[maxn];  <span class="comment">// sum_single[src]表示源点为src的最短路树的所有d之和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        solver.dijkstra(u);</span><br><span class="line">        sum_single[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != u)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> fa = solver.edges[solver.p[i]].u;</span><br><span class="line">                used[u][fa][i] = used[u][i][fa] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum_single[u] += (solver.d[i] == INF ? L : solver.d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += sum_single[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute_newc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)</span><br><span class="line">        <span class="keyword">if</span> (!used[u][a][b])</span><br><span class="line">            ans += sum_single[u];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            solver.dijkstra(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                ans += (solver.d[i] == INF ? L : solver.d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;L))</span><br><span class="line">    &#123;</span><br><span class="line">        solver.init(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                gr[i][j].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, s;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;s);</span><br><span class="line">            a--, b--;</span><br><span class="line">            gr[a][b].push_back(s), gr[b][a].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造网络</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (!gr[i][j].empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    sort(gr[i][j].begin(), gr[i][j].end());</span><br><span class="line">                    solver.AddEdge(i, j, gr[i][j][<span class="number">0</span>]);</span><br><span class="line">                    idx[i][j] = solver.m - <span class="number">1</span>;</span><br><span class="line">                    solver.AddEdge(j, i, gr[i][j][<span class="number">0</span>]);</span><br><span class="line">                    idx[j][i] = solver.m - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = compute_c(), c2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (!gr[i][j].empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> &amp;e1 = solver.edges[idx[i][j]].w,</span><br><span class="line">                        &amp;e2 = solver.edges[idx[j][i]].w;</span><br><span class="line">                    <span class="keyword">if</span> (gr[i][j].size() == <span class="number">1</span>)</span><br><span class="line">                        e1 = e2 = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        e1 = e2 = gr[i][j][<span class="number">1</span>];  <span class="comment">// 第二短边</span></span><br><span class="line">                    c2 = max(c2, compute_newc(i, j));</span><br><span class="line">                    e1 = e2 = gr[i][j][<span class="number">0</span>];  <span class="comment">// 恢复</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, c, c2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果用$floyd$算法计算$c$，每尝试着删除一条边都要重新计算一次，时间复杂度为$O(n^3m)$，很难承受。如果用$n$次$Dijkstra$计算单源最短路，时间复杂度为$O(nm^2\log n)$。虽然看上去比$O(n^3m)$略好，但由于$floyd$算法的常数
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA10917 【Walk Through the Forest】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA10917-%E3%80%90Walk-Through-the-Forest%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA10917-【Walk-Through-the-Forest】/</id>
    <published>2019-06-24T16:06:22.000Z</published>
    <updated>2019-06-24T16:06:38.560Z</updated>
    
    <content type="html"><![CDATA[<p>首先求出从每个点$u$回家的最短路长度$d[u]$，则题目中的条件“存在一条从$B$出发回家的路径，比所有从$A$出发回家的路径都短”实际上是指$d[B]&lt;d[A]$。这样，我们创建一个新的图，当且仅当$d[B]&lt;d[A]$时加入有向边$A-&gt;B$，则题目的目标就是求出起点到终点的路径条数。因为这个图是$DAG$，可以用动态规划求解。<br>去除模板后代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>, maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from, to, dist;</span><br><span class="line">        Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d) : from(u), to(v), dist(d) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> d, u;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> HeapNode &amp;rhs) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> d &gt; rhs.d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">bool</span> done[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn];</span><br><span class="line">    <span class="keyword">int</span> p[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dist)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.push_back(Edge(from, to, dist));</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        priority_queue&lt;HeapNode&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            d[i] = INF;</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(done, <span class="number">0</span>, <span class="keyword">sizeof</span>(done));</span><br><span class="line">        Q.push((HeapNode)&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            HeapNode x = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">int</span> u = x.u;</span><br><span class="line">            <span class="keyword">if</span> (done[u])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            done[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge &amp;e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (d[e.to] &gt; d[u] + e.dist)</span><br><span class="line">                &#123;</span><br><span class="line">                    d[e.to] = d[u] + e.dist;</span><br><span class="line">                    p[e.to] = G[u][i];</span><br><span class="line">                    Q.push((HeapNode)&#123;d[e.to], e.to&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> G[maxn][maxn], G2[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[u] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[u];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">        <span class="keyword">if</span> (G2[v][u])</span><br><span class="line">            ans += dfs(v);</span><br><span class="line">    <span class="keyword">return</span> dp[u] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (read(n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        read(m);</span><br><span class="line">        Dijkstra dij;</span><br><span class="line">        dij.init(n);</span><br><span class="line">        <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">        <span class="built_in">memset</span>(G2, <span class="number">0</span>, <span class="keyword">sizeof</span>(G2));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            read(u, v, w);</span><br><span class="line">            --u, --v;</span><br><span class="line">            dij.AddEdge(u, v, w);</span><br><span class="line">            dij.AddEdge(v, u, w);</span><br><span class="line">            G[u][v] = G[v][u] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dij.dijkstra(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (dij.d[j] &lt; dij.d[i] &amp;&amp; G[i][j])</span><br><span class="line">                    G2[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dij.d[i] &lt; dij.d[j] &amp;&amp; G[j][i])</span><br><span class="line">                    G2[j][i] = <span class="literal">true</span>;</span><br><span class="line">        writeln(dfs(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先求出从每个点$u$回家的最短路长度$d[u]$，则题目中的条件“存在一条从$B$出发回家的路径，比所有从$A$出发回家的路径都短”实际上是指$d[B]&amp;lt;d[A]$。这样，我们创建一个新的图，当且仅当$d[B]&amp;lt;d[A]$时加入有向边$A-&amp;gt;B$，则题目
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA10054 【The Necklace】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA10054-%E3%80%90The-Necklace%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA10054-【The-Necklace】/</id>
    <published>2019-06-24T16:05:23.000Z</published>
    <updated>2019-06-24T16:05:54.884Z</updated>
    
    <content type="html"><![CDATA[<p>如果把珠子看成点，似乎无法把题目转化成一个经典的、可以有效解决的问题，但如果把每种颜色看成一个结点，每个珠子的两半连一条有向边，则题目转化为了欧拉回路问题，可以在线性时间内解决。通过此题，数学建模的重要性可见一斑。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    Edge(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>) : u(u), v(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; ans;</span><br><span class="line"><span class="keyword">int</span> G[maxn + <span class="number">1</span>][maxn + <span class="number">1</span>], cnt[maxn + <span class="number">1</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= maxn; v++)</span><br><span class="line">        <span class="keyword">if</span> (G[u][v])</span><br><span class="line">        &#123;</span><br><span class="line">            G[u][v]--, G[v][u]--;</span><br><span class="line">            dfs(v);</span><br><span class="line">            ans.emplace_back(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= T; kase++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            G[u][v]++, G[v][u]++;</span><br><span class="line">            cnt[u]++, cnt[v]++;</span><br><span class="line">            start = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无向图的欧拉回路</span></span><br><span class="line">        <span class="keyword">bool</span> solved = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                solved = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  <span class="comment">// 检查度数</span></span><br><span class="line">        <span class="keyword">if</span> (solved)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            dfs(start);</span><br><span class="line">            <span class="keyword">if</span> (ans.size() != n || ans[<span class="number">0</span>].v != ans[ans.size() - <span class="number">1</span>].u)</span><br><span class="line">                solved = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d\n"</span>, kase);</span><br><span class="line">        <span class="keyword">if</span> (!solved)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"some beads may be lost\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans[i].u, ans[i].v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kase &lt; T)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ws;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果把珠子看成点，似乎无法把题目转化成一个经典的、可以有效解决的问题，但如果把每种颜色看成一个结点，每个珠子的两半连一条有向边，则题目转化为了欧拉回路问题，可以在线性时间内解决。通过此题，数学建模的重要性可见一斑。&lt;br&gt;代码如下：&lt;br&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 SP4033 【PHONELST - Phone List】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-SP4033-%E3%80%90PHONELST-Phone-List%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-SP4033-【PHONELST-Phone-List】/</id>
    <published>2019-06-22T08:15:19.000Z</published>
    <updated>2019-06-22T08:16:28.683Z</updated>
    
    <content type="html"><![CDATA[<p>考虑将所有的字符串构成一棵$Trie$，在构建过程中可以顺便判断答案。若当前串插入后没有新建任何结点，则当前串肯定是之前插入的某个串的前缀；若插入过程中，有某个经过的结点带有串结尾标记，则之前插入的某个串是当前串的前缀。依据上面两种情况判断结果。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">10</span>], cnt;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123; <span class="keyword">return</span> ch - <span class="string">'0'</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (!ch[u][c])</span><br><span class="line">                ch[u][c] = ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            u = ch[u][c];</span><br><span class="line">            <span class="keyword">if</span> (vis[u])</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; trie;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        trie.clear();</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s), ans |= trie.insert(s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ans ? <span class="string">"NO"</span> : <span class="string">"YES"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考虑将所有的字符串构成一棵$Trie$，在构建过程中可以顺便判断答案。若当前串插入后没有新建任何结点，则当前串肯定是之前插入的某个串的前缀；若插入过程中，有某个经过的结点带有串结尾标记，则之前插入的某个串是当前串的前缀。依据上面两种情况判断结果。&lt;br&gt;代码如下：&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="SPOJ" scheme="https://gandyli.xyz/tags/SPOJ/"/>
    
      <category term="Poj" scheme="https://gandyli.xyz/tags/Poj/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1401 【Remember the Word】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1401-%E3%80%90Remember-the-Word%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1401-【Remember-the-Word】/</id>
    <published>2019-06-22T08:14:37.000Z</published>
    <updated>2019-06-22T08:15:00.880Z</updated>
    
    <content type="html"><![CDATA[<p>不难想到这样的递推法：令$d(i)$表示从字符$i$开始的字符串（即后缀$S[i..L]$）的分解方案数，则$d(i)=sum\{d(i+len(x))|$单词$x$是$S[i..L]$的前缀$\}$。<br>如果先枚举$x$，再判断它是否为$S[i..L]$的前缀，时间无法接受（最多可能有$4000$个单词，判断还需要一定的时间）。可以换一个思路，先把所有单词组织成$Trie$，然后试着在$Trie$中“查找”$S[i..L]$。查找过程中每经过一个单词结点，就找到一个上述状态转移方程中的$x$，最多只需要比较$100$次就能找到所有的$x$。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">400005</span>, sigma_size = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字母表为全体小写字母的Trie</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxnode][sigma_size];</span><br><span class="line">    <span class="keyword">int</span> val[maxnode];</span><br><span class="line">    <span class="keyword">int</span> sz;  <span class="comment">// 结点总数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">    &#125;                                    <span class="comment">// 初始时只有一个根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c - <span class="string">'a'</span>; &#125;  <span class="comment">// 字符c的编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入字符串s，附加信息为v。注意v必须非0，因为0代表“本结点不是单词结点”</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (!ch[u][c])</span><br><span class="line">            &#123;  <span class="comment">// 结点不存在</span></span><br><span class="line">                <span class="built_in">memset</span>(ch[sz], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">                val[sz] = <span class="number">0</span>;      <span class="comment">// 中间结点的附加信息为0</span></span><br><span class="line">                ch[u][c] = sz++;  <span class="comment">// 新建结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            u = ch[u][c];  <span class="comment">// 往下走</span></span><br><span class="line">        &#125;</span><br><span class="line">        val[u] = v;  <span class="comment">// 字符串的最后一个字符的附加信息为v</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找字符串s的长度不超过len的前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_prefixes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'\0'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (!ch[u][c])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            u = ch[u][c];</span><br><span class="line">            <span class="keyword">if</span> (val[u] != <span class="number">0</span>)</span><br><span class="line">                ans.push_back(val[u]);  <span class="comment">// 找到一个前缀</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">300000</span> + <span class="number">10</span>;  <span class="comment">// 文本串最大长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxw = <span class="number">4000</span> + <span class="number">10</span>;    <span class="comment">// 单词最大个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxwl = <span class="number">100</span> + <span class="number">10</span>;    <span class="comment">// 每个单词最大长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">20071027</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxl], len[maxw], S;</span><br><span class="line"><span class="keyword">char</span> text[maxl], word[maxwl];</span><br><span class="line">Trie trie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, text, &amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        trie.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, word);</span><br><span class="line">            len[i] = <span class="built_in">strlen</span>(word);</span><br><span class="line">            trie.insert(word, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">int</span> L = <span class="built_in">strlen</span>(text);</span><br><span class="line">        d[L] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">            trie.find_prefixes(text + i, L - i, p);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; p.size(); j++)</span><br><span class="line">                d[i] = (d[i] + d[i + len[p[j]]]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, kase++, d[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不难想到这样的递推法：令$d(i)$表示从字符$i$开始的字符串（即后缀$S[i..L]$）的分解方案数，则$d(i)=sum\{d(i+len(x))|$单词$x$是$S[i..L]$的前缀$\}$。&lt;br&gt;如果先枚举$x$，再判断它是否为$S[i..L]$的前缀，时间无
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解-UVA1400-【&quot;Ray, Pass me the dishes!&quot;】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1400-%E3%80%90Ray-Pass-me-the-dishes-%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1400-【Ray-Pass-me-the-dishes-】/</id>
    <published>2019-06-22T08:11:54.000Z</published>
    <updated>2019-06-22T08:13:41.154Z</updated>
    
    <content type="html"><![CDATA[<p>本题看上去很像$RMQ$问题，但稍微琢磨一下就会发现本题和$RMQ$的重要区别：整个区间的解不能简单地通过各个子区间的解合并得到，所以$Sparse-Table$算法中的预处理和查询部分均不适用于本题。<br>本题的静态版本最大连续和子序列，它有一个分治算法：最优解要么完全在左半序列，要么完全在右半序列，要么跨越中点。由于线性算法的存在，这个算法可能并没有引起很多人的重视，但这个思路却是解决本题的关键。<br>构造一棵线段树，其中每个结点维护$3$个值：最大连续和$max$_$sub$、最大前缀和$max$_$prefix$与最大后缀和$max$_$suffix$。具体来说，$max$_$sub(a,b)$是满足$a\le x\le y\le b$且$D_x+D_{x+1}+…+D_y$的最大二元组$(x,y)$；$max$_$prefix(a,b)$是满足$a\le x\le b$且$D_a+D_{a+1}+…+D_x$最大的整数$x$；$max$_$suffix(a,b)$是满足$a\le x\le b$且$D_x+D_{x+1}+…+D_b$最大的整数$x$。<br>比如，$n=64$，询问为$(20,50)$，则线段$[20,50]$在线段树的根结点处被分成了两条线段$[20,32]$和$[33,50]$。则$max$_$sub(20,50)$的起点和终点有$3$种情况。<br>情况1：起点和终点都在$[20,32]$中，则$max$_$sub(20,50)=max$_$sub(20,32)$。<br>情况2：起点和终点都在$[33,50]$中，则$max$_$sub(20,50)=max$_$sub(33,50)$。<br>情况3：起点在$[20,32]$中，终点在$[33,50]$中，则$max$_$sub(20,50)=(max$_$suffix(20,32),max$_$prefix(33,50))$。<br>类似地，$max$_$prefix$和$max$_$suffix$也可以这样递推。建树的时间复杂度为$O(n)$，单组查询的时间复杂度为$O(\log n)$。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>, maxnode = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Interval;</span><br><span class="line"></span><br><span class="line">LL prefix_sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prefix_sum[R] - prefix_sum[L - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(Interval p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum(p.first, p.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Interval <span class="title">better</span><span class="params">(Interval a, Interval b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sum(a) != sum(b))</span><br><span class="line">    <span class="keyword">return</span> sum(a) &gt; sum(b) ? a : b;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? a : b; <span class="comment">// 利用pair自带的字典序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> qL, qR;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntervalTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> max_prefix[maxnode];</span><br><span class="line">  <span class="keyword">int</span> max_suffix[maxnode];</span><br><span class="line">  Interval max_sub[maxnode];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">    &#123;</span><br><span class="line">      max_prefix[o] = max_suffix[o] = L;</span><br><span class="line">      max_sub[o] = make_pair(L, L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 递归创建子树</span></span><br><span class="line">      <span class="keyword">int</span> lc = o * <span class="number">2</span>, rc = o * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">      build(lc, L, M);</span><br><span class="line">      build(rc, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递推max_prefix</span></span><br><span class="line">      LL v1 = sum(L, max_prefix[lc]);</span><br><span class="line">      LL v2 = sum(L, max_prefix[rc]);</span><br><span class="line">      <span class="keyword">if</span> (v1 == v2)</span><br><span class="line">        max_prefix[o] = min(max_prefix[lc], max_prefix[rc]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        max_prefix[o] = v1 &gt; v2 ? max_prefix[lc] : max_prefix[rc];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递推max_suffix</span></span><br><span class="line">      v1 = sum(max_suffix[lc], R);</span><br><span class="line">      v2 = sum(max_suffix[rc], R);</span><br><span class="line">      <span class="keyword">if</span> (v1 == v2)</span><br><span class="line">        max_suffix[o] = min(max_suffix[lc], max_suffix[rc]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        max_suffix[o] = v1 &gt; v2 ? max_suffix[lc] : max_suffix[rc];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递推max_sub</span></span><br><span class="line">      max_sub[o] = better(max_sub[lc], max_sub[rc]);                              <span class="comment">// 完全在左子树或者右子树</span></span><br><span class="line">      max_sub[o] = better(max_sub[o], make_pair(max_suffix[lc], max_prefix[rc])); <span class="comment">// 跨越中线</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Interval <span class="title">query_prefix</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (max_prefix[o] &lt;= qR)</span><br><span class="line">      <span class="keyword">return</span> make_pair(L, max_prefix[o]);</span><br><span class="line">    <span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = o * <span class="number">2</span>, rc = o * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qR &lt;= M)</span><br><span class="line">      <span class="keyword">return</span> query_prefix(lc, L, M);</span><br><span class="line">    Interval i = query_prefix(rc, M + <span class="number">1</span>, R);</span><br><span class="line">    i.first = L;</span><br><span class="line">    <span class="keyword">return</span> better(i, make_pair(L, max_prefix[lc]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Interval <span class="title">query_suffix</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (max_suffix[o] &gt;= qL)</span><br><span class="line">      <span class="keyword">return</span> make_pair(max_suffix[o], R);</span><br><span class="line">    <span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = o * <span class="number">2</span>, rc = o * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qL &gt; M)</span><br><span class="line">      <span class="keyword">return</span> query_suffix(rc, M + <span class="number">1</span>, R);</span><br><span class="line">    Interval i = query_suffix(lc, L, M);</span><br><span class="line">    i.second = R;</span><br><span class="line">    <span class="keyword">return</span> better(i, make_pair(max_suffix[rc], R));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Interval <span class="title">query</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qL &lt;= L &amp;&amp; R &lt;= qR)</span><br><span class="line">      <span class="keyword">return</span> max_sub[o];</span><br><span class="line">    <span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = o * <span class="number">2</span>, rc = o * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qR &lt;= M)</span><br><span class="line">      <span class="keyword">return</span> query(lc, L, M);</span><br><span class="line">    <span class="keyword">if</span> (qL &gt; M)</span><br><span class="line">      <span class="keyword">return</span> query(rc, M + <span class="number">1</span>, R);</span><br><span class="line">    Interval i1 = query_prefix(rc, M + <span class="number">1</span>, R); <span class="comment">// 右半的前缀</span></span><br><span class="line">    Interval i2 = query_suffix(lc, L, M);     <span class="comment">// 左半的后缀</span></span><br><span class="line">    Interval i3 = better(query(lc, L, M), query(rc, M + <span class="number">1</span>, R));</span><br><span class="line">    <span class="keyword">return</span> better(make_pair(i2.first, i1.second), i3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IntervalTree tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> kase = <span class="number">0</span>, n, a, Q;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q) == <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    prefix_sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">      prefix_sum[i + <span class="number">1</span>] = prefix_sum[i] + a;</span><br><span class="line">    &#125;</span><br><span class="line">    tree.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ++kase);</span><br><span class="line">    <span class="keyword">while</span> (Q--)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> L, R;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">      qL = L;</span><br><span class="line">      qR = R;</span><br><span class="line">      Interval ans = tree.query(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans.first, ans.second);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题看上去很像$RMQ$问题，但稍微琢磨一下就会发现本题和$RMQ$的重要区别：整个区间的解不能简单地通过各个子区间的解合并得到，所以$Sparse-Table$算法中的预处理和查询部分均不适用于本题。&lt;br&gt;本题的静态版本最大连续和子序列，它有一个分治算法：最优解要么完全
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA11021 【Tribles】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA11021-%E3%80%90Tribles%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA11021-【Tribles】/</id>
    <published>2019-06-22T08:08:36.000Z</published>
    <updated>2019-06-22T08:09:10.379Z</updated>
    
    <content type="html"><![CDATA[<p>由于每只麻球的后代独立存活，只需求出一开始只有$1$只麻球，$m$天后全部死亡的概率$f(m)$。由全概率公式，有：<br>$$f(i)=P_0+P_1f(i-1)+P_2f(i-2)^2+P_3f(i-3)^3+…+P_{n-1}f(i-1)^{n-1}$$<br>其中$P_jf(i-1)^j$的含义是这个麻球生了$j$个后代，它们在$i-1$天后全部死亡。注意这$j$个后代的死亡是独立的，而每个死亡的概率都是$f(i-1)$，因此根据乘法公式，$j$个后代全部死亡的概率为$f(i-1)^j$。同理，由于一开始共有$k$只麻球，且各只麻球的死亡是独立的，由乘法公式，最终答案是$f(m)^k$。代码如下（注意$m=0$的情况）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> P[maxn], f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= T; kase++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;P[i]);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">1</span>] = P[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                f[i] += P[j] * <span class="built_in">pow</span>(f[i - <span class="number">1</span>], j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %.7lf\n"</span>, kase, <span class="built_in">pow</span>(f[m], k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于每只麻球的后代独立存活，只需求出一开始只有$1$只麻球，$m$天后全部死亡的概率$f(m)$。由全概率公式，有：&lt;br&gt;$$f(i)=P_0+P_1f(i-1)+P_2f(i-2)^2+P_3f(i-3)^3+…+P_{n-1}f(i-1)^{n-1}$$&lt;br&gt;其中$
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1482 【Playing With Stones】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1482-%E3%80%90Playing-With-Stones%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1482-【Playing-With-Stones】/</id>
    <published>2019-06-22T08:05:58.000Z</published>
    <updated>2019-06-22T08:07:35.933Z</updated>
    
    <content type="html"><![CDATA[<p>本题和$Nim$游戏不同，但也可以看做$n$个单堆游戏之和。遗憾的是，即使是单堆游戏，由于$a_i$的范围太大，也不能按照定义递推出所有的$SG$函数。尽管如此，我们还是可以先写一个递推程序，看看$SG$函数有没有规律。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> SG[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SG[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j*<span class="number">2</span>&lt;=i; j++)</span><br><span class="line">            vis[SG[i-j]]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; ; j++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j]) </span><br><span class="line">            &#123;</span><br><span class="line">            SG[i]=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, SG[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印出来的结果是:<br>1 0 2 1 3 0 4 2 5 1 6 3 7 0 8 4 9 2 10 5 11 1 12 6 13 3 14 7 15.<br>我们发现，当$n$为偶数时，$SG(n)=n/2$，但$n$为奇数时似乎没什么规律。但当把$n$为偶数的值全部删除后得到的数列是 0 1 0 2 1 3 0 4 2 5 1 6 3 7…，和原数列是一样的。换句话说，当$n$为奇数时，$SG(n)=SG(n/2)$（$n/2$向下取整）。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">SG</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">1</span> ? SG(x &gt;&gt; <span class="number">1</span>) : (x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        LL a, v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a);</span><br><span class="line">            v ^=SG(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, v ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题和$Nim$游戏不同，但也可以看做$n$个单堆游戏之和。遗憾的是，即使是单堆游戏，由于$a_i$的范围太大，也不能按照定义递推出所有的$SG$函数。尽管如此，我们还是可以先写一个递推程序，看看$SG$函数有没有规律。代码如下：&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1069 【Always an integer】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1069-%E3%80%90Always-an-integer%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1069-【Always-an-integer】/</id>
    <published>2019-06-22T08:05:00.000Z</published>
    <updated>2019-06-22T08:05:23.234Z</updated>
    
    <content type="html"><![CDATA[<p>本题实际上是判断一个整系数多项式$P$的值是否总是正整数$D$的倍数。一个容易想到的方法是，随机代入很多整数计算$P/D$，如果全都是整数，那么很有可能是<code>Always an integer</code>；如果有的不是整数，那么答案必然是<code>Not always an integer</code>。<br>这个方法看起来有些投机取巧，但效果非常不错。事实上，不需要随机代入，只需要把$n=1,2,3,…,k+1$全试一遍就可以了，其中$k$试多项式中最高项的次数。<br>为什么可以这样做呢？让我们从$k$较小的情况开始研究。  </p><ul><li>当$k=0$时，$P$里根本就没有$n$个变量，所以只需代入$P(1)$计算即可。  </li><li>当$k=1$时，$P$时$n$的一次多项式，设为$an+b$，则$P(n+1)-P(n)=a$。如果把$P(n)$看成一个数列的第$n$项，则$\{P(n)\}$是一个首项为$P(1)$，公差为整数$a$的等差数列，因此只要首项和公差均为$D$的倍数，整个数列的所有项都会是$D$的倍数。因此只需验证$P(1)$和$P(2)$。  </li><li>当$k=2$时，$P$是$n$的二次多项式，设为$an^2+bn+c$，则$P(n+1)-P(n)=2an+a+b$。注意到这个$2an+a+b$是$n$的一次多项式，根据刚才的结论，只要$n=1$和$n=2$时它都是$D$的倍数，对于所有的正整数$n$，它都将是$D$的倍数。这样，相邻两项的差为$D$的倍数，再加上首项也为$D$的倍数，则$P(n)$将总是$D$的倍数。整理一下，只要$P(1),P(2)-P(1),P(3)-P(2)$都是$D$的倍数即可。这等价于验证$P(1),P(2)$和$P(3)$。<br>看到这里，结论已经不难猜到了。对于$k$次多项式$P(n)$，相邻两项之差$P(n+1)-P(n)$是关于$n$的$k-1$次多项式，根据数学归纳法，命题得证。顺别说一句，数列$dP(n)=P(n+1)-P(n)$称为$P(n)$的<strong>差分数列</strong>(difference series)。而差分数列的差分数列为二阶差分数列$d^2P(n)$，以此类推。<br>本题还要注意输入二项式的格式问题。输入格式翻译如下：<br>输入包含多组数据。每组数据仅一行，即一个多项式$(P)/D$，其中$P$是若干个形如$Cn^E$的项之和，其中系数$C$和$E$满足以下条件：  </li></ul><ol><li>$E$是一个满足$0\le E\le 100$的整数。如果$E=0$，则$Cn^E$写作$C$；如果$E=1$，则$Cn^E$写成$Cn$；除非$C$等于$1$或者$-1$（$C=1$时写作$n$，$C=-1$时写作$-n$）。</li><li>$C$是一个整数。如果$C$等于$1$或$-1$，且$E$不是$0$或者$1$，则$Cn^E$写成$n^E$或者$-n^E$。</li><li>只有不在第一项的非负$C$的前面才会有一个加号。</li><li>$E$的数值严格递减。</li><li>$C$和$D$都在$32$位带符号整数范围内。<br>输入结束标志为单个<strong>英文</strong>句号(<code>.</code>)。</li></ol><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Polynomial</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, p;  <span class="comment">// 第i项为a[i] * n^p[i]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parse_polynomial</span><span class="params">(<span class="built_in">string</span> expr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// 解析多项式（不带括号）</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, len = expr.size();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">        &#123;  <span class="comment">// 每次循环体解析一个a*n^p</span></span><br><span class="line">            <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (expr[i] == <span class="string">'+'</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (expr[i] == <span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="number">-1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len &amp;&amp; <span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">                v = v * <span class="number">10</span> + expr[i++] - <span class="string">'0'</span>;  <span class="comment">// 系数的绝对值</span></span><br><span class="line">            <span class="keyword">if</span> (i == len)</span><br><span class="line">            &#123;</span><br><span class="line">                a.push_back(v);</span><br><span class="line">                p.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;  <span class="comment">// 常数项</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="number">0</span>)</span><br><span class="line">                    v = <span class="number">1</span>;  <span class="comment">// 无系数，按1处理</span></span><br><span class="line">                v *= sign;</span><br><span class="line">                <span class="keyword">if</span> (expr[++i] == <span class="string">'^'</span>)</span><br><span class="line">                &#123;  <span class="comment">// 有指数项</span></span><br><span class="line">                    a.push_back(v);</span><br><span class="line">                    v = <span class="number">0</span>;  <span class="comment">// 清空v，接下来用v保存指数</span></span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; len &amp;&amp; <span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">                        v = v * <span class="number">10</span> + expr[i++] - <span class="string">'0'</span>;</span><br><span class="line">                    p.push_back(v);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;  <span class="comment">// 无指数项</span></span><br><span class="line">                    a.push_back(v);</span><br><span class="line">                    p.push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算f(x)除以MOD的余数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> MOD)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> m = a[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p[i]; j++)</span><br><span class="line">                m = m * <span class="number">1L</span>L * x % MOD;    <span class="comment">// 注意避免溢出</span></span><br><span class="line">            ans = (ans * <span class="number">1L</span>L + m) % MOD;  <span class="comment">// 加法也可能会溢出！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = expr.find(<span class="string">'/'</span>);</span><br><span class="line">    Polynomial poly;</span><br><span class="line">    poly.parse_polynomial(expr.substr(<span class="number">1</span>, p - <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">int</span> D = stoi(expr.substr(p + <span class="number">1</span>));  <span class="comment">// stoi是C++11新增的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= poly.p[<span class="number">0</span>] + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (poly.mod(i, D))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> expr;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, expr) &amp;&amp; expr[<span class="number">0</span>] != <span class="string">'.'</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %s\n"</span>, ++kase,</span><br><span class="line">               check(expr) ? <span class="string">"Always an integer"</span> : <span class="string">"Not always an integer"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题实际上是判断一个整系数多项式$P$的值是否总是正整数$D$的倍数。一个容易想到的方法是，随机代入很多整数计算$P/D$，如果全都是整数，那么很有可能是&lt;code&gt;Always an integer&lt;/code&gt;；如果有的不是整数，那么答案必然是&lt;code&gt;Not alw
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA11426 【拿行李（极限版） GCD - Extreme (II)】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA11426-%E3%80%90%E6%8B%BF%E8%A1%8C%E6%9D%8E%EF%BC%88%E6%9E%81%E9%99%90%E7%89%88%EF%BC%89-GCD-Extreme-II-%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA11426-【拿行李（极限版）-GCD-Extreme-II-】/</id>
    <published>2019-06-22T08:03:43.000Z</published>
    <updated>2019-06-22T08:04:09.696Z</updated>
    
    <content type="html"><![CDATA[<p>设$f(n)=\gcd(1,n)+\gcd(2,n)+\gcd(3,n)+…+\gcd(n-1,n)$,则所求答案为$S(n)=f(2)+f(3)+…+f(n)$。只需求出$f(n)$，就可以递推出所有答案：$S(n)=S(n-1)+f(n)$。因此，本题的重点在于如何计算$f(n)$。<br>注意到所有$\gcd(x,n)$的值都是$n$的约数，可以按照这个约数进行分类，用$g(n,i)$表示满足$gcd(x,n)=i$且$x&lt;n$的正整数$x$的个数，则$f(n)=sum\{i\times g(n,i)|i\text{是}n\text{的约数}\}$。注意到$\gcd(x,n)=i$的充要条件是$\gcd(x/i,n/i)=1$，因此满足条件的$x/i$有$phi(n/i)$个，说明$g(n,i)=phi(n/i)$。<br>问题到这里还没有结束。如果依次计算$f(n)$，需要对每个$n$枚举它的约数$i$，速度较慢，但如果把思路逆转过来，对于每个$i$枚举它的倍数$n$（并且更新$f(n)$的值），时间复杂度将降为与素数筛法同阶。至此，问题得到了完整的解决。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_table</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!phi[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!phi[j])</span><br><span class="line">                    phi[j] = j;</span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL S[maxn + <span class="number">1</span>], f[maxn + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi_table(maxn);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = i * <span class="number">2</span>; n &lt;= maxn; n += i)</span><br><span class="line">            f[n] += i * phi[n / i];</span><br><span class="line">    S[<span class="number">2</span>] = f[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">3</span>; n &lt;= maxn; n++)</span><br><span class="line">        S[n] = S[n - <span class="number">1</span>] + f[n];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, S[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设$f(n)=\gcd(1,n)+\gcd(2,n)+\gcd(3,n)+…+\gcd(n-1,n)$,则所求答案为$S(n)=f(2)+f(3)+…+f(n)$。只需求出$f(n)$，就可以递推出所有答案：$S(n)=S(n-1)+f(n)$。因此，本题的重点在于如何计算
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 Luogu P5238 【整数校验器】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-Luogu-P5238-%E3%80%90%E6%95%B4%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%99%A8%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-Luogu-P5238-【整数校验器】/</id>
    <published>2019-06-22T08:02:07.000Z</published>
    <updated>2019-06-22T08:03:15.773Z</updated>
    
    <content type="html"><![CDATA[<p>简单的模拟，用<code>string</code>可以简化代码。<br>注意判断<code>x</code>是否在$[l, r]$范围内需要考虑负数。</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = __int128;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar()))</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL L = read(), R = read(), T = read();</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; str.length() != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="comment">// 如果这个数不是0但开头是0则不合法</span></span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">if</span> (str.length() == <span class="number">1</span> || (str.length() &gt; <span class="number">1</span> &amp;&amp; str[<span class="number">1</span>] == <span class="string">'0'</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="comment">// 如果只有一个'-'或-号后为0则不合法</span></span><br><span class="line">        LL num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = (str[<span class="number">0</span>] == <span class="string">'-'</span>); i &lt; str.length(); i++)</span><br><span class="line">            num = (num &lt;&lt; <span class="number">1</span>) + (num &lt;&lt; <span class="number">3</span>) + (str[i] - <span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">            num *= <span class="number">-1</span>; <span class="comment">// 考虑负数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (num &lt; L || num &gt; R ? <span class="number">2</span> : <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 在区间内</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的模拟，用&lt;code&gt;string&lt;/code&gt;可以简化代码。&lt;br&gt;注意判断&lt;code&gt;x&lt;/code&gt;是否在$[l, r]$范围内需要考虑负数。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://gandyli.xyz/tags/Luogu/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA11995 【I Can Guess the Data Structure!】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA11995-%E3%80%90I-Can-Guess-the-Data-Structure-%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA11995-【I-Can-Guess-the-Data-Structure-】/</id>
    <published>2019-02-17T16:02:33.000Z</published>
    <updated>2019-02-23T10:44:17.225Z</updated>
    
    <content type="html"><![CDATA[<p>本题考察了栈、队列和优先队列3种$\text{ADT}$的概念。只要熟悉这些概念，本题不难解决。事实上，$\text{STL}$ 中已经封装好了这3种数据结构，分别是<code>stack</code>，<code>queue</code>和<code>priority_queue</code>。这样，本题只需要依次判断输入是否有可能是栈，队列或优先队列，然后综合起来即可。注意到题目中说的“无错误的返回”，因此在执行<code>pop</code>操作的时候要调用一下<code>empty()</code>，否则可能会异常退出。</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[maxn], B[maxn], n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> x = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (x != B[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s.push(B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (x != B[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q.push(B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckPQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span> (x != B[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pq.push(B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A[i], &amp;B[i]);</span><br><span class="line">        <span class="keyword">int</span> Stack = CheckStack(), Queue = CheckQueue();</span><br><span class="line">        <span class="keyword">int</span> sum = Stack + Queue + CheckPQ();</span><br><span class="line">        <span class="keyword">if</span> (!sum)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"impossible"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"not sure"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Stack)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"stack"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Queue)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"queue"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"priority queue"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题考察了栈、队列和优先队列3种$\text{ADT}$的概念。只要熟悉这些概念，本题不难解决。事实上，$\text{STL}$ 中已经封装好了这3种数据结构，分别是&lt;code&gt;stack&lt;/code&gt;，&lt;code&gt;queue&lt;/code&gt;和&lt;code&gt;priority_q
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1362 【Exploring Pyramids】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1362-%E3%80%90Exploring-Pyramids%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1362-【Exploring-Pyramids】/</id>
    <published>2019-01-25T13:23:00.000Z</published>
    <updated>2019-02-01T10:06:24.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一棵多叉树，每个结点的任意两个子结点都有左右之分。从根结点开始，每次尽量往左走，走不通了就回溯，把遇到的字母顺次记录下来，可以得到一个序列。如图所示的$5$个图的序列均为<code>ABABABA</code>。给定一个序列，问有多少棵树与之对应。<a id="more"></a><br><img src="https://i.loli.net/2019/01/25/5c4b0b522d6bc.png" alt="404 Not Found, Please Called @andyli."></p><h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><p>设输入序列为$S$，$d(i,j)$为子序列$S_i$，$S_{i+1}$，…，$S_j$对应的树的个数，则边界条件是$d(i,i)=1$，且$S_i\not= S_j$时$d(i,j)=0$（因为起点和终点应是同一点）。在其他情况下，设第一个分支在$S_k$时回到树根（必须有$S_i=S_k$），则这个分支对应的序列是$S_{i+1}$，…，$S_{k-1}$，方案数为$d(i+1,k-1)$；其他分支对应的访问序列为$S_k$，…，$S_j$，方案数为$d(k,j)$。这样，在非边界情况，递推关系为$d(i,j)=\text{sum}\{d(i+1,k-1)\times d(k,j)|i+2\le k\le j, S_i=S_k=S_j\}$。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">305</span>, MOD = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (S[i] != S[j])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;ans = d[i][j];</span><br><span class="line">    <span class="keyword">if</span> (ans &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">2</span>; k &lt;= j; k++)</span><br><span class="line">        <span class="keyword">if</span> (S[i] == S[k])</span><br><span class="line">            ans = (ans + (LL)dp(i + <span class="number">1</span>, k - <span class="number">1</span>) * (LL)dp(k, j)) % MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp(<span class="number">0</span>, <span class="built_in">strlen</span>(S) - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给出一棵多叉树，每个结点的任意两个子结点都有左右之分。从根结点开始，每次尽量往左走，走不通了就回溯，把遇到的字母顺次记录下来，可以得到一个序列。如图所示的$5$个图的序列均为&lt;code&gt;ABABABA&lt;/code&gt;。给定一个序列，问有多少棵树与之对应。
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1339 【Ancient Cipher】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1339-%E3%80%90Ancient-Cipher%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1339-【Ancient-Cipher】/</id>
    <published>2018-12-22T06:33:06.000Z</published>
    <updated>2018-12-26T13:24:28.219Z</updated>
    
    <content type="html"><![CDATA[<p>直接统计字符个数，排序后比较各个字母出现的数量。<br>代码如下：<a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt1[maxn], cnt2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt1, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt1));</span><br><span class="line">        <span class="built_in">memset</span>(cnt2, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt2));</span><br><span class="line">        <span class="keyword">size_t</span> len = s1.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt1[s1[i] - <span class="string">'A'</span>]++;</span><br><span class="line">            cnt2[s2[i] - <span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(cnt1, cnt1 + <span class="number">26</span>);</span><br><span class="line">        sort(cnt2, cnt2 + <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt1[i] != cnt2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//代码仅供参考，请各位自行编写代码，严禁抄袭</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直接统计字符个数，排序后比较各个字母出现的数量。&lt;br&gt;代码如下：
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA400 【Unix ls】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA400-%E3%80%90Unix-ls%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA400-【Unix-ls】/</id>
    <published>2018-12-22T06:31:56.000Z</published>
    <updated>2018-12-26T13:25:13.048Z</updated>
    
    <content type="html"><![CDATA[<p>这一题可以先算出$M$,行数和列数，然后逐行逐列输出。<br>代码如下：<a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxcol = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> name[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> len, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - str.length(); i++)</span><br><span class="line">        <span class="built_in">cout</span>.put(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; name[i];</span><br><span class="line">            m = max(m, (<span class="keyword">int</span>)name[i].length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = (maxcol - m) / (m + <span class="number">2</span>) + <span class="number">1</span>, </span><br><span class="line">            r = (n - <span class="number">1</span>) / c + <span class="number">1</span>;</span><br><span class="line">        print(<span class="string">""</span>, <span class="number">60</span>, <span class="string">'-'</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sort(name, name + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = j * r + i;</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt; n) print(name[tmp], j == c - <span class="number">1</span> ? m : m + <span class="number">2</span>, <span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一题可以先算出$M$,行数和列数，然后逐行逐列输出。&lt;br&gt;代码如下：
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA10815 【Andy&#39;s First Dictionary】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA10815-%E3%80%90Andy-s-First-Dictionary%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA10815-【Andy-s-First-Dictionary】/</id>
    <published>2018-12-22T06:26:49.000Z</published>
    <updated>2018-12-26T13:24:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>本题没有太多的技巧，只是考验<code>STL</code>的用法，可以用<code>set</code>保存各个单词<del>，还可以用输出迭代器（<code>ostream_iterator</code>）来输出</del>。注意：输入时应把所有非字母的字符变成空格，然后利用<code>stringstream</code>得到各个单词。提示一下，<code>set</code>会自动排序，所以不用<code>sort</code>进行排序。代码如下（本人一贯偷懒，所以利用C++11来小小的简化了代码）：<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 提供copy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  // 提供cin, cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;  // 提供ostream_iterator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;   // 提供stringstream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;    // 提供string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;    // 提供isalpha, tolower</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;       // 提供set</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s, tmp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : s) <span class="comment">// C++11</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalpha</span>(x))</span><br><span class="line">                x = <span class="built_in">tolower</span>(x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x = <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; tmp)</span><br><span class="line">            d.insert(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    ostream_iterator&lt;<span class="built_in">string</span>&gt; out(<span class="built_in">cout</span>, <span class="string">"\n"</span>);</span><br><span class="line">    copy(d.begin(), d.end(), out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题没有太多的技巧，只是考验&lt;code&gt;STL&lt;/code&gt;的用法，可以用&lt;code&gt;set&lt;/code&gt;保存各个单词&lt;del&gt;，还可以用输出迭代器（&lt;code&gt;ostream_iterator&lt;/code&gt;）来输出&lt;/del&gt;。注意：输入时应把所有非字母的字符变成空格，然后利用&lt;code&gt;stringstream&lt;/code&gt;得到各个单词。提示一下，&lt;code&gt;set&lt;/code&gt;会自动排序，所以不用&lt;code&gt;sort&lt;/code&gt;进行排序。代码如下（本人一贯偷懒，所以利用C++11来小小的简化了代码）：
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
</feed>
