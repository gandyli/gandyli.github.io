<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>andyli的博客</title>
  
  <subtitle>做最好的自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gandyli.xyz/"/>
  <updated>2019-06-22T08:16:28.683Z</updated>
  <id>https://gandyli.xyz/</id>
  
  <author>
    <name>andyli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>题解 SP4033 【PHONELST - Phone List】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-SP4033-%E3%80%90PHONELST-Phone-List%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-SP4033-【PHONELST-Phone-List】/</id>
    <published>2019-06-22T08:15:19.000Z</published>
    <updated>2019-06-22T08:16:28.683Z</updated>
    
    <content type="html"><![CDATA[<p>考虑将所有的字符串构成一棵$Trie$，在构建过程中可以顺便判断答案。若当前串插入后没有新建任何结点，则当前串肯定是之前插入的某个串的前缀；若插入过程中，有某个经过的结点带有串结尾标记，则之前插入的某个串是当前串的前缀。依据上面两种情况判断结果。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">10</span>], cnt;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123; <span class="keyword">return</span> ch - <span class="string">'0'</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (!ch[u][c])</span><br><span class="line">                ch[u][c] = ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            u = ch[u][c];</span><br><span class="line">            <span class="keyword">if</span> (vis[u])</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; trie;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        trie.clear();</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s), ans |= trie.insert(s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ans ? <span class="string">"NO"</span> : <span class="string">"YES"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考虑将所有的字符串构成一棵$Trie$，在构建过程中可以顺便判断答案。若当前串插入后没有新建任何结点，则当前串肯定是之前插入的某个串的前缀；若插入过程中，有某个经过的结点带有串结尾标记，则之前插入的某个串是当前串的前缀。依据上面两种情况判断结果。&lt;br&gt;代码如下：&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="SPOJ" scheme="https://gandyli.xyz/tags/SPOJ/"/>
    
      <category term="Poj" scheme="https://gandyli.xyz/tags/Poj/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1401 【Remember the Word】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1401-%E3%80%90Remember-the-Word%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1401-【Remember-the-Word】/</id>
    <published>2019-06-22T08:14:37.000Z</published>
    <updated>2019-06-22T08:15:00.880Z</updated>
    
    <content type="html"><![CDATA[<p>不难想到这样的递推法：令$d(i)$表示从字符$i$开始的字符串（即后缀$S[i..L]$）的分解方案数，则$d(i)=sum\{d(i+len(x))|$单词$x$是$S[i..L]$的前缀$\}$。<br>如果先枚举$x$，再判断它是否为$S[i..L]$的前缀，时间无法接受（最多可能有$4000$个单词，判断还需要一定的时间）。可以换一个思路，先把所有单词组织成$Trie$，然后试着在$Trie$中“查找”$S[i..L]$。查找过程中每经过一个单词结点，就找到一个上述状态转移方程中的$x$，最多只需要比较$100$次就能找到所有的$x$。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">400005</span>, sigma_size = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字母表为全体小写字母的Trie</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxnode][sigma_size];</span><br><span class="line">    <span class="keyword">int</span> val[maxnode];</span><br><span class="line">    <span class="keyword">int</span> sz;  <span class="comment">// 结点总数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">    &#125;                                    <span class="comment">// 初始时只有一个根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c - <span class="string">'a'</span>; &#125;  <span class="comment">// 字符c的编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入字符串s，附加信息为v。注意v必须非0，因为0代表“本结点不是单词结点”</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (!ch[u][c])</span><br><span class="line">            &#123;  <span class="comment">// 结点不存在</span></span><br><span class="line">                <span class="built_in">memset</span>(ch[sz], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">                val[sz] = <span class="number">0</span>;      <span class="comment">// 中间结点的附加信息为0</span></span><br><span class="line">                ch[u][c] = sz++;  <span class="comment">// 新建结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            u = ch[u][c];  <span class="comment">// 往下走</span></span><br><span class="line">        &#125;</span><br><span class="line">        val[u] = v;  <span class="comment">// 字符串的最后一个字符的附加信息为v</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找字符串s的长度不超过len的前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_prefixes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'\0'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (!ch[u][c])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            u = ch[u][c];</span><br><span class="line">            <span class="keyword">if</span> (val[u] != <span class="number">0</span>)</span><br><span class="line">                ans.push_back(val[u]);  <span class="comment">// 找到一个前缀</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">300000</span> + <span class="number">10</span>;  <span class="comment">// 文本串最大长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxw = <span class="number">4000</span> + <span class="number">10</span>;    <span class="comment">// 单词最大个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxwl = <span class="number">100</span> + <span class="number">10</span>;    <span class="comment">// 每个单词最大长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">20071027</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxl], len[maxw], S;</span><br><span class="line"><span class="keyword">char</span> text[maxl], word[maxwl];</span><br><span class="line">Trie trie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, text, &amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        trie.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, word);</span><br><span class="line">            len[i] = <span class="built_in">strlen</span>(word);</span><br><span class="line">            trie.insert(word, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">int</span> L = <span class="built_in">strlen</span>(text);</span><br><span class="line">        d[L] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">            trie.find_prefixes(text + i, L - i, p);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; p.size(); j++)</span><br><span class="line">                d[i] = (d[i] + d[i + len[p[j]]]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, kase++, d[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不难想到这样的递推法：令$d(i)$表示从字符$i$开始的字符串（即后缀$S[i..L]$）的分解方案数，则$d(i)=sum\{d(i+len(x))|$单词$x$是$S[i..L]$的前缀$\}$。&lt;br&gt;如果先枚举$x$，再判断它是否为$S[i..L]$的前缀，时间无
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解-UVA1400-【&quot;Ray, Pass me the dishes!&quot;】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1400-%E3%80%90Ray-Pass-me-the-dishes-%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1400-【Ray-Pass-me-the-dishes-】/</id>
    <published>2019-06-22T08:11:54.000Z</published>
    <updated>2019-06-22T08:13:41.154Z</updated>
    
    <content type="html"><![CDATA[<p>本题看上去很像$RMQ$问题，但稍微琢磨一下就会发现本题和$RMQ$的重要区别：整个区间的解不能简单地通过各个子区间的解合并得到，所以$Sparse-Table$算法中的预处理和查询部分均不适用于本题。<br>本题的静态版本最大连续和子序列，它有一个分治算法：最优解要么完全在左半序列，要么完全在右半序列，要么跨越中点。由于线性算法的存在，这个算法可能并没有引起很多人的重视，但这个思路却是解决本题的关键。<br>构造一棵线段树，其中每个结点维护$3$个值：最大连续和$max$_$sub$、最大前缀和$max$_$prefix$与最大后缀和$max$_$suffix$。具体来说，$max$_$sub(a,b)$是满足$a\le x\le y\le b$且$D_x+D_{x+1}+…+D_y$的最大二元组$(x,y)$；$max$_$prefix(a,b)$是满足$a\le x\le b$且$D_a+D_{a+1}+…+D_x$最大的整数$x$；$max$_$suffix(a,b)$是满足$a\le x\le b$且$D_x+D_{x+1}+…+D_b$最大的整数$x$。<br>比如，$n=64$，询问为$(20,50)$，则线段$[20,50]$在线段树的根结点处被分成了两条线段$[20,32]$和$[33,50]$。则$max$_$sub(20,50)$的起点和终点有$3$种情况。<br>情况1：起点和终点都在$[20,32]$中，则$max$_$sub(20,50)=max$_$sub(20,32)$。<br>情况2：起点和终点都在$[33,50]$中，则$max$_$sub(20,50)=max$_$sub(33,50)$。<br>情况3：起点在$[20,32]$中，终点在$[33,50]$中，则$max$_$sub(20,50)=(max$_$suffix(20,32),max$_$prefix(33,50))$。<br>类似地，$max$_$prefix$和$max$_$suffix$也可以这样递推。建树的时间复杂度为$O(n)$，单组查询的时间复杂度为$O(\log n)$。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>, maxnode = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Interval;</span><br><span class="line"></span><br><span class="line">LL prefix_sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prefix_sum[R] - prefix_sum[L - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(Interval p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum(p.first, p.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Interval <span class="title">better</span><span class="params">(Interval a, Interval b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sum(a) != sum(b))</span><br><span class="line">    <span class="keyword">return</span> sum(a) &gt; sum(b) ? a : b;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? a : b; <span class="comment">// 利用pair自带的字典序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> qL, qR;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntervalTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> max_prefix[maxnode];</span><br><span class="line">  <span class="keyword">int</span> max_suffix[maxnode];</span><br><span class="line">  Interval max_sub[maxnode];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">    &#123;</span><br><span class="line">      max_prefix[o] = max_suffix[o] = L;</span><br><span class="line">      max_sub[o] = make_pair(L, L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 递归创建子树</span></span><br><span class="line">      <span class="keyword">int</span> lc = o * <span class="number">2</span>, rc = o * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">      build(lc, L, M);</span><br><span class="line">      build(rc, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递推max_prefix</span></span><br><span class="line">      LL v1 = sum(L, max_prefix[lc]);</span><br><span class="line">      LL v2 = sum(L, max_prefix[rc]);</span><br><span class="line">      <span class="keyword">if</span> (v1 == v2)</span><br><span class="line">        max_prefix[o] = min(max_prefix[lc], max_prefix[rc]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        max_prefix[o] = v1 &gt; v2 ? max_prefix[lc] : max_prefix[rc];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递推max_suffix</span></span><br><span class="line">      v1 = sum(max_suffix[lc], R);</span><br><span class="line">      v2 = sum(max_suffix[rc], R);</span><br><span class="line">      <span class="keyword">if</span> (v1 == v2)</span><br><span class="line">        max_suffix[o] = min(max_suffix[lc], max_suffix[rc]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        max_suffix[o] = v1 &gt; v2 ? max_suffix[lc] : max_suffix[rc];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递推max_sub</span></span><br><span class="line">      max_sub[o] = better(max_sub[lc], max_sub[rc]);                              <span class="comment">// 完全在左子树或者右子树</span></span><br><span class="line">      max_sub[o] = better(max_sub[o], make_pair(max_suffix[lc], max_prefix[rc])); <span class="comment">// 跨越中线</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Interval <span class="title">query_prefix</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (max_prefix[o] &lt;= qR)</span><br><span class="line">      <span class="keyword">return</span> make_pair(L, max_prefix[o]);</span><br><span class="line">    <span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = o * <span class="number">2</span>, rc = o * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qR &lt;= M)</span><br><span class="line">      <span class="keyword">return</span> query_prefix(lc, L, M);</span><br><span class="line">    Interval i = query_prefix(rc, M + <span class="number">1</span>, R);</span><br><span class="line">    i.first = L;</span><br><span class="line">    <span class="keyword">return</span> better(i, make_pair(L, max_prefix[lc]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Interval <span class="title">query_suffix</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (max_suffix[o] &gt;= qL)</span><br><span class="line">      <span class="keyword">return</span> make_pair(max_suffix[o], R);</span><br><span class="line">    <span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = o * <span class="number">2</span>, rc = o * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qL &gt; M)</span><br><span class="line">      <span class="keyword">return</span> query_suffix(rc, M + <span class="number">1</span>, R);</span><br><span class="line">    Interval i = query_suffix(lc, L, M);</span><br><span class="line">    i.second = R;</span><br><span class="line">    <span class="keyword">return</span> better(i, make_pair(max_suffix[rc], R));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Interval <span class="title">query</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qL &lt;= L &amp;&amp; R &lt;= qR)</span><br><span class="line">      <span class="keyword">return</span> max_sub[o];</span><br><span class="line">    <span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = o * <span class="number">2</span>, rc = o * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qR &lt;= M)</span><br><span class="line">      <span class="keyword">return</span> query(lc, L, M);</span><br><span class="line">    <span class="keyword">if</span> (qL &gt; M)</span><br><span class="line">      <span class="keyword">return</span> query(rc, M + <span class="number">1</span>, R);</span><br><span class="line">    Interval i1 = query_prefix(rc, M + <span class="number">1</span>, R); <span class="comment">// 右半的前缀</span></span><br><span class="line">    Interval i2 = query_suffix(lc, L, M);     <span class="comment">// 左半的后缀</span></span><br><span class="line">    Interval i3 = better(query(lc, L, M), query(rc, M + <span class="number">1</span>, R));</span><br><span class="line">    <span class="keyword">return</span> better(make_pair(i2.first, i1.second), i3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IntervalTree tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> kase = <span class="number">0</span>, n, a, Q;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q) == <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    prefix_sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">      prefix_sum[i + <span class="number">1</span>] = prefix_sum[i] + a;</span><br><span class="line">    &#125;</span><br><span class="line">    tree.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ++kase);</span><br><span class="line">    <span class="keyword">while</span> (Q--)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> L, R;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">      qL = L;</span><br><span class="line">      qR = R;</span><br><span class="line">      Interval ans = tree.query(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans.first, ans.second);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题看上去很像$RMQ$问题，但稍微琢磨一下就会发现本题和$RMQ$的重要区别：整个区间的解不能简单地通过各个子区间的解合并得到，所以$Sparse-Table$算法中的预处理和查询部分均不适用于本题。&lt;br&gt;本题的静态版本最大连续和子序列，它有一个分治算法：最优解要么完全
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA11021 【Tribles】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA11021-%E3%80%90Tribles%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA11021-【Tribles】/</id>
    <published>2019-06-22T08:08:36.000Z</published>
    <updated>2019-06-22T08:09:10.379Z</updated>
    
    <content type="html"><![CDATA[<p>由于每只麻球的后代独立存活，只需求出一开始只有$1$只麻球，$m$天后全部死亡的概率$f(m)$。由全概率公式，有：<br>$$f(i)=P_0+P_1f(i-1)+P_2f(i-2)^2+P_3f(i-3)^3+…+P_{n-1}f(i-1)^{n-1}$$<br>其中$P_jf(i-1)^j$的含义是这个麻球生了$j$个后代，它们在$i-1$天后全部死亡。注意这$j$个后代的死亡是独立的，而每个死亡的概率都是$f(i-1)$，因此根据乘法公式，$j$个后代全部死亡的概率为$f(i-1)^j$。同理，由于一开始共有$k$只麻球，且各只麻球的死亡是独立的，由乘法公式，最终答案是$f(m)^k$。代码如下（注意$m=0$的情况）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> P[maxn], f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= T; kase++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;P[i]);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">1</span>] = P[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                f[i] += P[j] * <span class="built_in">pow</span>(f[i - <span class="number">1</span>], j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %.7lf\n"</span>, kase, <span class="built_in">pow</span>(f[m], k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于每只麻球的后代独立存活，只需求出一开始只有$1$只麻球，$m$天后全部死亡的概率$f(m)$。由全概率公式，有：&lt;br&gt;$$f(i)=P_0+P_1f(i-1)+P_2f(i-2)^2+P_3f(i-3)^3+…+P_{n-1}f(i-1)^{n-1}$$&lt;br&gt;其中$
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1482 【Playing With Stones】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1482-%E3%80%90Playing-With-Stones%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1482-【Playing-With-Stones】/</id>
    <published>2019-06-22T08:05:58.000Z</published>
    <updated>2019-06-22T08:07:35.933Z</updated>
    
    <content type="html"><![CDATA[<p>本题和$Nim$游戏不同，但也可以看做$n$个单堆游戏之和。遗憾的是，即使是单堆游戏，由于$a_i$的范围太大，也不能按照定义递推出所有的$SG$函数。尽管如此，我们还是可以先写一个递推程序，看看$SG$函数有没有规律。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> SG[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SG[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j*<span class="number">2</span>&lt;=i; j++)</span><br><span class="line">            vis[SG[i-j]]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; ; j++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j]) </span><br><span class="line">            &#123;</span><br><span class="line">            SG[i]=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, SG[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印出来的结果是:<br>1 0 2 1 3 0 4 2 5 1 6 3 7 0 8 4 9 2 10 5 11 1 12 6 13 3 14 7 15.<br>我们发现，当$n$为偶数时，$SG(n)=n/2$，但$n$为奇数时似乎没什么规律。但当把$n$为偶数的值全部删除后得到的数列是 0 1 0 2 1 3 0 4 2 5 1 6 3 7…，和原数列是一样的。换句话说，当$n$为奇数时，$SG(n)=SG(n/2)$（$n/2$向下取整）。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">SG</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">1</span> ? SG(x &gt;&gt; <span class="number">1</span>) : (x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        LL a, v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a);</span><br><span class="line">            v ^=SG(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, v ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题和$Nim$游戏不同，但也可以看做$n$个单堆游戏之和。遗憾的是，即使是单堆游戏，由于$a_i$的范围太大，也不能按照定义递推出所有的$SG$函数。尽管如此，我们还是可以先写一个递推程序，看看$SG$函数有没有规律。代码如下：&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1069 【Always an integer】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1069-%E3%80%90Always-an-integer%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1069-【Always-an-integer】/</id>
    <published>2019-06-22T08:05:00.000Z</published>
    <updated>2019-06-22T08:05:23.234Z</updated>
    
    <content type="html"><![CDATA[<p>本题实际上是判断一个整系数多项式$P$的值是否总是正整数$D$的倍数。一个容易想到的方法是，随机代入很多整数计算$P/D$，如果全都是整数，那么很有可能是<code>Always an integer</code>；如果有的不是整数，那么答案必然是<code>Not always an integer</code>。<br>这个方法看起来有些投机取巧，但效果非常不错。事实上，不需要随机代入，只需要把$n=1,2,3,…,k+1$全试一遍就可以了，其中$k$试多项式中最高项的次数。<br>为什么可以这样做呢？让我们从$k$较小的情况开始研究。  </p><ul><li>当$k=0$时，$P$里根本就没有$n$个变量，所以只需代入$P(1)$计算即可。  </li><li>当$k=1$时，$P$时$n$的一次多项式，设为$an+b$，则$P(n+1)-P(n)=a$。如果把$P(n)$看成一个数列的第$n$项，则$\{P(n)\}$是一个首项为$P(1)$，公差为整数$a$的等差数列，因此只要首项和公差均为$D$的倍数，整个数列的所有项都会是$D$的倍数。因此只需验证$P(1)$和$P(2)$。  </li><li>当$k=2$时，$P$是$n$的二次多项式，设为$an^2+bn+c$，则$P(n+1)-P(n)=2an+a+b$。注意到这个$2an+a+b$是$n$的一次多项式，根据刚才的结论，只要$n=1$和$n=2$时它都是$D$的倍数，对于所有的正整数$n$，它都将是$D$的倍数。这样，相邻两项的差为$D$的倍数，再加上首项也为$D$的倍数，则$P(n)$将总是$D$的倍数。整理一下，只要$P(1),P(2)-P(1),P(3)-P(2)$都是$D$的倍数即可。这等价于验证$P(1),P(2)$和$P(3)$。<br>看到这里，结论已经不难猜到了。对于$k$次多项式$P(n)$，相邻两项之差$P(n+1)-P(n)$是关于$n$的$k-1$次多项式，根据数学归纳法，命题得证。顺别说一句，数列$dP(n)=P(n+1)-P(n)$称为$P(n)$的<strong>差分数列</strong>(difference series)。而差分数列的差分数列为二阶差分数列$d^2P(n)$，以此类推。<br>本题还要注意输入二项式的格式问题。输入格式翻译如下：<br>输入包含多组数据。每组数据仅一行，即一个多项式$(P)/D$，其中$P$是若干个形如$Cn^E$的项之和，其中系数$C$和$E$满足以下条件：  </li></ul><ol><li>$E$是一个满足$0\le E\le 100$的整数。如果$E=0$，则$Cn^E$写作$C$；如果$E=1$，则$Cn^E$写成$Cn$；除非$C$等于$1$或者$-1$（$C=1$时写作$n$，$C=-1$时写作$-n$）。</li><li>$C$是一个整数。如果$C$等于$1$或$-1$，且$E$不是$0$或者$1$，则$Cn^E$写成$n^E$或者$-n^E$。</li><li>只有不在第一项的非负$C$的前面才会有一个加号。</li><li>$E$的数值严格递减。</li><li>$C$和$D$都在$32$位带符号整数范围内。<br>输入结束标志为单个<strong>英文</strong>句号(<code>.</code>)。</li></ol><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Polynomial</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, p;  <span class="comment">// 第i项为a[i] * n^p[i]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parse_polynomial</span><span class="params">(<span class="built_in">string</span> expr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// 解析多项式（不带括号）</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, len = expr.size();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">        &#123;  <span class="comment">// 每次循环体解析一个a*n^p</span></span><br><span class="line">            <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (expr[i] == <span class="string">'+'</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (expr[i] == <span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="number">-1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len &amp;&amp; <span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">                v = v * <span class="number">10</span> + expr[i++] - <span class="string">'0'</span>;  <span class="comment">// 系数的绝对值</span></span><br><span class="line">            <span class="keyword">if</span> (i == len)</span><br><span class="line">            &#123;</span><br><span class="line">                a.push_back(v);</span><br><span class="line">                p.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;  <span class="comment">// 常数项</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="number">0</span>)</span><br><span class="line">                    v = <span class="number">1</span>;  <span class="comment">// 无系数，按1处理</span></span><br><span class="line">                v *= sign;</span><br><span class="line">                <span class="keyword">if</span> (expr[++i] == <span class="string">'^'</span>)</span><br><span class="line">                &#123;  <span class="comment">// 有指数项</span></span><br><span class="line">                    a.push_back(v);</span><br><span class="line">                    v = <span class="number">0</span>;  <span class="comment">// 清空v，接下来用v保存指数</span></span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; len &amp;&amp; <span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">                        v = v * <span class="number">10</span> + expr[i++] - <span class="string">'0'</span>;</span><br><span class="line">                    p.push_back(v);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;  <span class="comment">// 无指数项</span></span><br><span class="line">                    a.push_back(v);</span><br><span class="line">                    p.push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算f(x)除以MOD的余数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> MOD)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> m = a[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p[i]; j++)</span><br><span class="line">                m = m * <span class="number">1L</span>L * x % MOD;    <span class="comment">// 注意避免溢出</span></span><br><span class="line">            ans = (ans * <span class="number">1L</span>L + m) % MOD;  <span class="comment">// 加法也可能会溢出！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = expr.find(<span class="string">'/'</span>);</span><br><span class="line">    Polynomial poly;</span><br><span class="line">    poly.parse_polynomial(expr.substr(<span class="number">1</span>, p - <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">int</span> D = stoi(expr.substr(p + <span class="number">1</span>));  <span class="comment">// stoi是C++11新增的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= poly.p[<span class="number">0</span>] + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (poly.mod(i, D))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> expr;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, expr) &amp;&amp; expr[<span class="number">0</span>] != <span class="string">'.'</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %s\n"</span>, ++kase,</span><br><span class="line">               check(expr) ? <span class="string">"Always an integer"</span> : <span class="string">"Not always an integer"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题实际上是判断一个整系数多项式$P$的值是否总是正整数$D$的倍数。一个容易想到的方法是，随机代入很多整数计算$P/D$，如果全都是整数，那么很有可能是&lt;code&gt;Always an integer&lt;/code&gt;；如果有的不是整数，那么答案必然是&lt;code&gt;Not alw
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA11426 【拿行李（极限版） GCD - Extreme (II)】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA11426-%E3%80%90%E6%8B%BF%E8%A1%8C%E6%9D%8E%EF%BC%88%E6%9E%81%E9%99%90%E7%89%88%EF%BC%89-GCD-Extreme-II-%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA11426-【拿行李（极限版）-GCD-Extreme-II-】/</id>
    <published>2019-06-22T08:03:43.000Z</published>
    <updated>2019-06-22T08:04:09.696Z</updated>
    
    <content type="html"><![CDATA[<p>设$f(n)=\gcd(1,n)+\gcd(2,n)+\gcd(3,n)+…+\gcd(n-1,n)$,则所求答案为$S(n)=f(2)+f(3)+…+f(n)$。只需求出$f(n)$，就可以递推出所有答案：$S(n)=S(n-1)+f(n)$。因此，本题的重点在于如何计算$f(n)$。<br>注意到所有$\gcd(x,n)$的值都是$n$的约数，可以按照这个约数进行分类，用$g(n,i)$表示满足$gcd(x,n)=i$且$x&lt;n$的正整数$x$的个数，则$f(n)=sum\{i\times g(n,i)|i\text{是}n\text{的约数}\}$。注意到$\gcd(x,n)=i$的充要条件是$\gcd(x/i,n/i)=1$，因此满足条件的$x/i$有$phi(n/i)$个，说明$g(n,i)=phi(n/i)$。<br>问题到这里还没有结束。如果依次计算$f(n)$，需要对每个$n$枚举它的约数$i$，速度较慢，但如果把思路逆转过来，对于每个$i$枚举它的倍数$n$（并且更新$f(n)$的值），时间复杂度将降为与素数筛法同阶。至此，问题得到了完整的解决。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_table</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!phi[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!phi[j])</span><br><span class="line">                    phi[j] = j;</span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL S[maxn + <span class="number">1</span>], f[maxn + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi_table(maxn);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = i * <span class="number">2</span>; n &lt;= maxn; n += i)</span><br><span class="line">            f[n] += i * phi[n / i];</span><br><span class="line">    S[<span class="number">2</span>] = f[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">3</span>; n &lt;= maxn; n++)</span><br><span class="line">        S[n] = S[n - <span class="number">1</span>] + f[n];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, S[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设$f(n)=\gcd(1,n)+\gcd(2,n)+\gcd(3,n)+…+\gcd(n-1,n)$,则所求答案为$S(n)=f(2)+f(3)+…+f(n)$。只需求出$f(n)$，就可以递推出所有答案：$S(n)=S(n-1)+f(n)$。因此，本题的重点在于如何计算
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 Luogu P5238 【整数校验器】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-Luogu-P5238-%E3%80%90%E6%95%B4%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%99%A8%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-Luogu-P5238-【整数校验器】/</id>
    <published>2019-06-22T08:02:07.000Z</published>
    <updated>2019-06-22T08:03:15.773Z</updated>
    
    <content type="html"><![CDATA[<p>简单的模拟，用<code>string</code>可以简化代码。<br>注意判断<code>x</code>是否在$[l, r]$范围内需要考虑负数。</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = __int128;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar()))</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL L = read(), R = read(), T = read();</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; str.length() != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="comment">// 如果这个数不是0但开头是0则不合法</span></span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">if</span> (str.length() == <span class="number">1</span> || (str.length() &gt; <span class="number">1</span> &amp;&amp; str[<span class="number">1</span>] == <span class="string">'0'</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="comment">// 如果只有一个'-'或-号后为0则不合法</span></span><br><span class="line">        LL num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = (str[<span class="number">0</span>] == <span class="string">'-'</span>); i &lt; str.length(); i++)</span><br><span class="line">            num = (num &lt;&lt; <span class="number">1</span>) + (num &lt;&lt; <span class="number">3</span>) + (str[i] - <span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">            num *= <span class="number">-1</span>; <span class="comment">// 考虑负数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (num &lt; L || num &gt; R ? <span class="number">2</span> : <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 在区间内</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的模拟，用&lt;code&gt;string&lt;/code&gt;可以简化代码。&lt;br&gt;注意判断&lt;code&gt;x&lt;/code&gt;是否在$[l, r]$范围内需要考虑负数。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://gandyli.xyz/tags/Luogu/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA11995 【I Can Guess the Data Structure!】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA11995-%E3%80%90I-Can-Guess-the-Data-Structure-%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA11995-【I-Can-Guess-the-Data-Structure-】/</id>
    <published>2019-02-17T16:02:33.000Z</published>
    <updated>2019-02-23T10:44:17.225Z</updated>
    
    <content type="html"><![CDATA[<p>本题考察了栈、队列和优先队列3种$\text{ADT}$的概念。只要熟悉这些概念，本题不难解决。事实上，$\text{STL}$ 中已经封装好了这3种数据结构，分别是<code>stack</code>，<code>queue</code>和<code>priority_queue</code>。这样，本题只需要依次判断输入是否有可能是栈，队列或优先队列，然后综合起来即可。注意到题目中说的“无错误的返回”，因此在执行<code>pop</code>操作的时候要调用一下<code>empty()</code>，否则可能会异常退出。</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[maxn], B[maxn], n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> x = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (x != B[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s.push(B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (x != B[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q.push(B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckPQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span> (x != B[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pq.push(B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A[i], &amp;B[i]);</span><br><span class="line">        <span class="keyword">int</span> Stack = CheckStack(), Queue = CheckQueue();</span><br><span class="line">        <span class="keyword">int</span> sum = Stack + Queue + CheckPQ();</span><br><span class="line">        <span class="keyword">if</span> (!sum)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"impossible"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"not sure"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Stack)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"stack"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Queue)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"queue"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"priority queue"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题考察了栈、队列和优先队列3种$\text{ADT}$的概念。只要熟悉这些概念，本题不难解决。事实上，$\text{STL}$ 中已经封装好了这3种数据结构，分别是&lt;code&gt;stack&lt;/code&gt;，&lt;code&gt;queue&lt;/code&gt;和&lt;code&gt;priority_q
      
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1362 【Exploring Pyramids】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1362-%E3%80%90Exploring-Pyramids%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1362-【Exploring-Pyramids】/</id>
    <published>2019-01-25T13:23:00.000Z</published>
    <updated>2019-02-01T10:06:24.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一棵多叉树，每个结点的任意两个子结点都有左右之分。从根结点开始，每次尽量往左走，走不通了就回溯，把遇到的字母顺次记录下来，可以得到一个序列。如图所示的$5$个图的序列均为<code>ABABABA</code>。给定一个序列，问有多少棵树与之对应。<a id="more"></a><br><img src="https://i.loli.net/2019/01/25/5c4b0b522d6bc.png" alt="404 Not Found, Please Called @andyli."></p><h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><p>设输入序列为$S$，$d(i,j)$为子序列$S_i$，$S_{i+1}$，…，$S_j$对应的树的个数，则边界条件是$d(i,i)=1$，且$S_i\not= S_j$时$d(i,j)=0$（因为起点和终点应是同一点）。在其他情况下，设第一个分支在$S_k$时回到树根（必须有$S_i=S_k$），则这个分支对应的序列是$S_{i+1}$，…，$S_{k-1}$，方案数为$d(i+1,k-1)$；其他分支对应的访问序列为$S_k$，…，$S_j$，方案数为$d(k,j)$。这样，在非边界情况，递推关系为$d(i,j)=\text{sum}\{d(i+1,k-1)\times d(k,j)|i+2\le k\le j, S_i=S_k=S_j\}$。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">305</span>, MOD = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (S[i] != S[j])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;ans = d[i][j];</span><br><span class="line">    <span class="keyword">if</span> (ans &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">2</span>; k &lt;= j; k++)</span><br><span class="line">        <span class="keyword">if</span> (S[i] == S[k])</span><br><span class="line">            ans = (ans + (LL)dp(i + <span class="number">1</span>, k - <span class="number">1</span>) * (LL)dp(k, j)) % MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp(<span class="number">0</span>, <span class="built_in">strlen</span>(S) - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给出一棵多叉树，每个结点的任意两个子结点都有左右之分。从根结点开始，每次尽量往左走，走不通了就回溯，把遇到的字母顺次记录下来，可以得到一个序列。如图所示的$5$个图的序列均为&lt;code&gt;ABABABA&lt;/code&gt;。给定一个序列，问有多少棵树与之对应。
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1339 【Ancient Cipher】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1339-%E3%80%90Ancient-Cipher%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1339-【Ancient-Cipher】/</id>
    <published>2018-12-22T06:33:06.000Z</published>
    <updated>2018-12-26T13:24:28.219Z</updated>
    
    <content type="html"><![CDATA[<p>直接统计字符个数，排序后比较各个字母出现的数量。<br>代码如下：<a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt1[maxn], cnt2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt1, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt1));</span><br><span class="line">        <span class="built_in">memset</span>(cnt2, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt2));</span><br><span class="line">        <span class="keyword">size_t</span> len = s1.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt1[s1[i] - <span class="string">'A'</span>]++;</span><br><span class="line">            cnt2[s2[i] - <span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(cnt1, cnt1 + <span class="number">26</span>);</span><br><span class="line">        sort(cnt2, cnt2 + <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt1[i] != cnt2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//代码仅供参考，请各位自行编写代码，严禁抄袭</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直接统计字符个数，排序后比较各个字母出现的数量。&lt;br&gt;代码如下：
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA400 【Unix ls】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA400-%E3%80%90Unix-ls%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA400-【Unix-ls】/</id>
    <published>2018-12-22T06:31:56.000Z</published>
    <updated>2018-12-26T13:25:13.048Z</updated>
    
    <content type="html"><![CDATA[<p>这一题可以先算出$M$,行数和列数，然后逐行逐列输出。<br>代码如下：<a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxcol = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> name[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> len, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - str.length(); i++)</span><br><span class="line">        <span class="built_in">cout</span>.put(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; name[i];</span><br><span class="line">            m = max(m, (<span class="keyword">int</span>)name[i].length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = (maxcol - m) / (m + <span class="number">2</span>) + <span class="number">1</span>, </span><br><span class="line">            r = (n - <span class="number">1</span>) / c + <span class="number">1</span>;</span><br><span class="line">        print(<span class="string">""</span>, <span class="number">60</span>, <span class="string">'-'</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sort(name, name + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = j * r + i;</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt; n) print(name[tmp], j == c - <span class="number">1</span> ? m : m + <span class="number">2</span>, <span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一题可以先算出$M$,行数和列数，然后逐行逐列输出。&lt;br&gt;代码如下：
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA10815 【Andy&#39;s First Dictionary】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA10815-%E3%80%90Andy-s-First-Dictionary%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA10815-【Andy-s-First-Dictionary】/</id>
    <published>2018-12-22T06:26:49.000Z</published>
    <updated>2018-12-26T13:24:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>本题没有太多的技巧，只是考验<code>STL</code>的用法，可以用<code>set</code>保存各个单词<del>，还可以用输出迭代器（<code>ostream_iterator</code>）来输出</del>。注意：输入时应把所有非字母的字符变成空格，然后利用<code>stringstream</code>得到各个单词。提示一下，<code>set</code>会自动排序，所以不用<code>sort</code>进行排序。代码如下（本人一贯偷懒，所以利用C++11来小小的简化了代码）：<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 提供copy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  // 提供cin, cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;  // 提供ostream_iterator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;   // 提供stringstream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;    // 提供string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;    // 提供isalpha, tolower</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;       // 提供set</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s, tmp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : s) <span class="comment">// C++11</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalpha</span>(x))</span><br><span class="line">                x = <span class="built_in">tolower</span>(x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x = <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; tmp)</span><br><span class="line">            d.insert(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    ostream_iterator&lt;<span class="built_in">string</span>&gt; out(<span class="built_in">cout</span>, <span class="string">"\n"</span>);</span><br><span class="line">    copy(d.begin(), d.end(), out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题没有太多的技巧，只是考验&lt;code&gt;STL&lt;/code&gt;的用法，可以用&lt;code&gt;set&lt;/code&gt;保存各个单词&lt;del&gt;，还可以用输出迭代器（&lt;code&gt;ostream_iterator&lt;/code&gt;）来输出&lt;/del&gt;。注意：输入时应把所有非字母的字符变成空格，然后利用&lt;code&gt;stringstream&lt;/code&gt;得到各个单词。提示一下，&lt;code&gt;set&lt;/code&gt;会自动排序，所以不用&lt;code&gt;sort&lt;/code&gt;进行排序。代码如下（本人一贯偷懒，所以利用C++11来小小的简化了代码）：
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA1641 【ASCII面积 ASCII Area】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA1641-%E3%80%90ASCII%E9%9D%A2%E7%A7%AF-ASCII-Area%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA1641-【ASCII面积-ASCII-Area】/</id>
    <published>2018-12-22T06:25:23.000Z</published>
    <updated>2018-12-30T10:05:51.751Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道和几何相关的题目（废话），不过不需要高深的几何知识。</p><p>每一个格子要么全白，要么全黑，要么半白半黑，只要能准确的判断出来即可。</p><p>字符<code>\</code>和<code>/</code>都是半白半黑，问题在于<code>.</code>到底是全白还是全黑。<a id="more"></a></p><p>解决方法是从上到下从左到右处理，沿途统计<code>/</code>和<code>\</code>。当这两个字符出现偶数次时说明接下来的格子在多边形外；奇数次则说明接下来的格子在多边形内。</p><p>可以用一个变量来判断是否在多边形外。<br>AC代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> c;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'/'</span> || c == <span class="string">'\\'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    flag = !flag;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'.'</span> &amp;&amp; flag)</span><br><span class="line">                    ans += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans / <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道和几何相关的题目（废话），不过不需要高深的几何知识。&lt;/p&gt;
&lt;p&gt;每一个格子要么全白，要么全黑，要么半白半黑，只要能准确的判断出来即可。&lt;/p&gt;
&lt;p&gt;字符&lt;code&gt;\&lt;/code&gt;和&lt;code&gt;/&lt;/code&gt;都是半白半黑，问题在于&lt;code&gt;.&lt;/code&gt;到底是全白还是全黑。
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 Luogu P1379 【八数码难题】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-Luogu-P1379-%E3%80%90%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-Luogu-P1379-【八数码难题】/</id>
    <published>2018-12-22T06:25:23.000Z</published>
    <updated>2019-03-30T09:22:28.757Z</updated>
    
    <content type="html"><![CDATA[<p>八数码问题其实就是图上的最短路问题，图的“节点”就是$9$个格子中的滑块编号（从上到下，从左到右把它们放到一个包含$9$个元素的数组中）。无权图上的最短路问题可以用<code>BFS</code>求解。<a id="more"></a></p><hr><p>树的<code>BFS</code>不需要判重，因为根本不会重复；但对于图来说，如果不判重，时间和空间都将产生极大的浪费。 楼下的判重方式建议不要学习，因为用一个九维数组一共有$9^9=387420489$项，太多了，数组可能开不下。实际结点数并没有这么多，$0$~$8$的排列总共只有$9!=362880$个。这样的用法存在大量的浪费…——数组中有很多项都没有被用到，但却占据了空间。</p><hr><p>第一种办法是把排列变成整数，这样只开一个一维数组就可以了。（效率还行）。但是适用范围不大：如果隐式图的总结点数非常大，编码也会很大，数组还是开不下。</p><hr><p>第二种办法是使用哈希（<code>hash</code>）技术（简单地说，是把结点变成整数，但不必一一对应）。（比赛中最常用）</p><hr><p>第三种方法是利用<code>STL</code>集合。（代码最好写），但是效率比较慢，建议在时间紧迫或对效率要求不太高的情况下使用，或者仅把它作为“跳板”——先写一个<code>STL</code>的程序，确保主算法正确，然后把<code>set</code>替换成自己写的哈希表。</p><hr><p>这里利用第二种方法，因为比赛中比较常用，而且执行效率很高。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> State = <span class="keyword">int</span>[<span class="number">9</span>]; <span class="comment">// 定义“状态”类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxstate = <span class="number">1000000</span>;</span><br><span class="line">State st[maxstate], goal = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>&#125;; <span class="comment">// 状态数组。所有状态都保存在这里</span></span><br><span class="line"><span class="keyword">int</span> dist[maxstate]; <span class="comment">// 距离数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myhash <span class="comment">// STL有许多函数名是hash的函数，为了保险最好用名称空间（换个名字也可以），个人习惯</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> hashsize = <span class="number">1000003</span>;</span><br><span class="line">    <span class="keyword">int</span> head[hashsize], next[maxstate];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init_lookup_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(State&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把9个数字组合成9位数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            v = v * <span class="number">10</span> + s[i];</span><br><span class="line">        <span class="keyword">return</span> v % hashsize;</span><br><span class="line">        <span class="comment">// 确保hash值是不超过hash表的大小的非负整数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">try_to_insert</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(st[s]);</span><br><span class="line">        <span class="keyword">int</span> u = head[h]; <span class="comment">// 从表头开始查找链表</span></span><br><span class="line">        <span class="keyword">while</span> (u)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找到了，插入失败</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(st[u], st[s], <span class="keyword">sizeof</span>(st[s])))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            u = next[u]; <span class="comment">// 顺着链表接着找</span></span><br><span class="line">        &#125;</span><br><span class="line">        next[s] = head[h]; <span class="comment">// 插入到链表中</span></span><br><span class="line">        head[h] = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS，返回目标状态在st数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myhash::init_lookup_table(); <span class="comment">// 初始化查找表</span></span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">1</span>, rear = <span class="number">2</span>; <span class="comment">// 不使用下标0，因为0被看做“不存在”</span></span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear)</span><br><span class="line">    &#123;</span><br><span class="line">        State&amp; s = st[front]; <span class="comment">// 用引用简化代码</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(goal, s, <span class="keyword">sizeof</span>(s)))</span><br><span class="line">            <span class="keyword">return</span> front; <span class="comment">// 找到目标状态，成功返回</span></span><br><span class="line">        <span class="keyword">int</span> z;</span><br><span class="line">        <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">9</span>; z++)</span><br><span class="line">            <span class="keyword">if</span> (!s[z])</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找“0”的位置</span></span><br><span class="line">        <span class="comment">// 获取行列编号（0~2） </span></span><br><span class="line">        <span class="keyword">int</span> x = z / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> y = z % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> newx = x + dx[d];</span><br><span class="line">            <span class="keyword">int</span> newy = y + dy[d];</span><br><span class="line">            <span class="keyword">int</span> newz = newx * <span class="number">3</span> + newy;</span><br><span class="line">            <span class="keyword">if</span> (newx &gt;= <span class="number">0</span> &amp;&amp; newx &lt; <span class="number">3</span> &amp;&amp; newy &gt;= <span class="number">0</span> &amp;&amp; newy &lt; <span class="number">3</span>)</span><br><span class="line">            &#123; <span class="comment">// 如果移动合法</span></span><br><span class="line">                State&amp; t = st[rear]; <span class="comment">// 扩展新结点</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;t, &amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">                t[newz] = s[z];</span><br><span class="line">                t[z] = s[newz];</span><br><span class="line">                <span class="comment">// 更新新结点的距离值</span></span><br><span class="line">                dist[rear] = dist[front] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果成功插入查找表，修改队尾指针</span></span><br><span class="line">                <span class="keyword">if</span> (myhash::try_to_insert(rear))</span><br><span class="line">                    rear++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp; <span class="comment">// 起始状态</span></span><br><span class="line">        st[<span class="number">1</span>][i] = tmp - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = bfs(); <span class="comment">// 返回目标状态的下标</span></span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dist[ans] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：本代码用的是<code>C++11</code>新标准。</p><p>提示：某些特定的<code>STL</code>实现还有<code>hash_set</code>，它正是基于前面的哈希表，但它并不是标准<code>C++</code>的一部分，因此不是所有情况下都可用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;八数码问题其实就是图上的最短路问题，图的“节点”就是$9$个格子中的滑块编号（从上到下，从左到右把它们放到一个包含$9$个元素的数组中）。无权图上的最短路问题可以用&lt;code&gt;BFS&lt;/code&gt;求解。
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://gandyli.xyz/tags/Luogu/"/>
    
  </entry>
  
  <entry>
    <title>题解 UVA11462 【Age Sort】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-UVA11462-%E3%80%90Age-Sort%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-UVA11462-【Age-Sort】/</id>
    <published>2018-12-22T06:23:53.000Z</published>
    <updated>2018-12-26T13:24:18.606Z</updated>
    
    <content type="html"><![CDATA[<p>由于数据量太大，这里不建议使用快排函数。这里可以利用整数范围很小这个条件来使用计数排序方法。下面是程序代码：<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x, c[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            c[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c[i]; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!first) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                first = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果还要精益求精，可以优化输入输出，进一步降低运行时间。程序如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">readint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c))</span><br><span class="line">        c = getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">10</span>]; <span class="comment">// 声明成全局变量可以减小开销</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeint</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        p++; <span class="comment">// 特殊情况：i等于0时需要输出0，而不是什么也不输出</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">while</span> (i)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[p++] = i % <span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = p - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'0'</span> + buf[j]); <span class="comment">// 逆序输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, c[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">while</span> (n = readint())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            c[readint()]++;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c[i]; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!first) </span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">                first = <span class="number">0</span>;</span><br><span class="line">                writeint(i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述优化使得运行时间缩短了约$\frac{2}{3}$。一般情况下，当输入输出数据量很大时，应尽量用scanf和printf函数（而不是cin和cout）；如果时间效率还不够高，应逐字符输入输出，就像上面的readint和writeint函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于数据量太大，这里不建议使用快排函数。这里可以利用整数范围很小这个条件来使用计数排序方法。下面是程序代码：
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVa" scheme="https://gandyli.xyz/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>题解 Luogu P2955 【USACO09OCT 奇数偶数Even? Odd? 】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-Luogu-P2955-%E3%80%90USACO09OCT-%E5%A5%87%E6%95%B0%E5%81%B6%E6%95%B0Even-Odd-%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-Luogu-P2955-【USACO09OCT-奇数偶数Even-Odd-】/</id>
    <published>2018-12-22T06:22:34.000Z</published>
    <updated>2018-12-26T13:24:47.470Z</updated>
    
    <content type="html"><![CDATA[<p>这题其实很简单，代码相信大家都能看懂，只要注意C++的不要用<code>long long</code>，pascal的不要用<code>int64</code>，大家用<code>string</code>就可以了。<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (((str.back() ^ <span class="number">48</span>) &amp; <span class="number">1</span>) ? <span class="string">"odd"</span> : <span class="string">"even"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这题其实很简单，代码相信大家都能看懂，只要注意C++的不要用&lt;code&gt;long long&lt;/code&gt;，pascal的不要用&lt;code&gt;int64&lt;/code&gt;，大家用&lt;code&gt;string&lt;/code&gt;就可以了。
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://gandyli.xyz/tags/Luogu/"/>
    
      <category term="USACO" scheme="https://gandyli.xyz/tags/USACO/"/>
    
      <category term="2009" scheme="https://gandyli.xyz/tags/2009/"/>
    
  </entry>
  
  <entry>
    <title>题解 Luogu P4711 【「化学」相对分子质量】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-Luogu-P4711-%E3%80%90%E3%80%8C%E5%8C%96%E5%AD%A6%E3%80%8D%E7%9B%B8%E5%AF%B9%E5%88%86%E5%AD%90%E8%B4%A8%E9%87%8F%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-Luogu-P4711-【「化学」相对分子质量】/</id>
    <published>2018-12-22T06:20:21.000Z</published>
    <updated>2018-12-26T13:25:01.096Z</updated>
    
    <content type="html"><![CDATA[<p><del>话说这题为什么是 <code>提高+省选-</code></del><br>这题只要按照题目说的做就可以了（用递归会比较好）<br>代码如下：<a id="more"></a><br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &lt;cctype&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &lt;map&gt;</span></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="keyword">double</span>&gt; m<span class="comment">;</span></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    m[<span class="string">"H"</span>] = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"C"</span>] = <span class="number">12</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"N"</span>] = <span class="number">14</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"O"</span>] = <span class="number">16</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"F"</span>] = <span class="number">19</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Na"</span>] = <span class="number">23</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Mg"</span>] = <span class="number">24</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Al"</span>] = <span class="number">27</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Si"</span>] = <span class="number">28</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"P"</span>] = <span class="number">31</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"S"</span>] = <span class="number">32</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Cl"</span>] = <span class="number">35.5</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"K"</span>] = <span class="number">39</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Ca"</span>] = <span class="number">40</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Mn"</span>] = <span class="number">55</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Fe"</span>] = <span class="number">56</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Cu"</span>] = <span class="number">64</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Zn"</span>] = <span class="number">65</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Ag"</span>] = <span class="number">108</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"I"</span>] = <span class="number">127</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Ba"</span>] = <span class="number">137</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Hf"</span>] = <span class="number">178.5</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Pt"</span>] = <span class="number">195</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Au"</span>] = <span class="number">197</span><span class="comment">;</span></span><br><span class="line">    m[<span class="string">"Hg"</span>] = <span class="number">201</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> f(string <span class="keyword">str</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.count(<span class="keyword">str</span>))</span><br><span class="line">        <span class="keyword">return</span> m[<span class="keyword">str</span>]<span class="comment">;</span></span><br><span class="line">    size_t <span class="keyword">pos</span> = str.find(<span class="string">'~'</span>)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">pos</span> != string::npos)</span><br><span class="line">        <span class="keyword">return</span> f(str.substr(<span class="number">0</span>, <span class="keyword">pos</span>)) + f(str.substr(<span class="keyword">pos</span> + <span class="number">1</span>))<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (isupper(<span class="keyword">str</span>[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>, flag = bool(islower(<span class="keyword">str</span>[<span class="number">1</span>])), ok = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">str</span>[flag + <span class="number">1</span>] == <span class="string">'_'</span>)</span><br><span class="line">            t = stoi(str.substr(flag + <span class="number">3</span>, (<span class="keyword">pos</span> = str.find(<span class="string">'&#125;'</span>)) - flag - <span class="number">3</span>)), ok = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">return</span> t * m[str.substr(<span class="number">0</span>, flag + <span class="number">1</span>)] + f(str.substr(ok ? (<span class="keyword">pos</span> + <span class="number">1</span>) : (flag + <span class="number">1</span>)))<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>, i = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">while</span> (isdigit(<span class="keyword">str</span>[i]))</span><br><span class="line">        t = t * <span class="number">10</span> + <span class="keyword">str</span>[i++] - <span class="string">'0'</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> t * f(str.substr(i))<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">str</span>[<span class="number">0</span>] == <span class="string">'('</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">cnt</span> = <span class="number">1</span>, len = str.length()<span class="comment">;</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span><span class="comment">; i &lt; len; i++)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">str</span>[i] == <span class="string">'('</span>)</span><br><span class="line">                <span class="keyword">cnt</span>++<span class="comment">;</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">str</span>[i] == <span class="string">')'</span>)</span><br><span class="line">                <span class="keyword">cnt</span>--<span class="comment">;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">cnt</span> == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">str</span>[i + <span class="number">1</span>] == <span class="string">'_'</span>)</span><br><span class="line">            t = stoi(str.substr(i + <span class="number">3</span>, (<span class="keyword">pos</span> = str.find(i + <span class="number">3</span>, <span class="string">'&#125;'</span>)) - i - <span class="number">3</span>)), <span class="keyword">cnt</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">return</span> t * f(str.substr(<span class="number">1</span>, i - <span class="number">1</span>)) + f(str.substr(<span class="keyword">cnt</span> ? (i + <span class="number">1</span>) : (<span class="keyword">pos</span> + <span class="number">1</span>)))<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    init()<span class="comment">;</span></span><br><span class="line">    string <span class="keyword">str</span><span class="comment">;</span></span><br><span class="line">    cin &gt;&gt; <span class="keyword">str</span><span class="comment">;</span></span><br><span class="line">    cout &lt;&lt; f(<span class="keyword">str</span>) &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码可能有点乱，但只要认真一看就会发现其实这题很简单。<br>大家有没有注意到代码中的<code>f</code>函数中，用到了一个函数<code>stoi</code>，这个函数是<code>C++11</code>新增的，可以把字符串变成整数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;话说这题为什么是 &lt;code&gt;提高+省选-&lt;/code&gt;&lt;/del&gt;&lt;br&gt;这题只要按照题目说的做就可以了（用递归会比较好）&lt;br&gt;代码如下：
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://gandyli.xyz/tags/Luogu/"/>
    
  </entry>
  
  <entry>
    <title>题解 Luogu P3879 【TJOI2010 阅读理解】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-Luogu-P3879-%E3%80%90TJOI2010-%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-Luogu-P3879-【TJOI2010-阅读理解】/</id>
    <published>2018-12-22T04:14:05.000Z</published>
    <updated>2018-12-26T13:24:50.642Z</updated>
    
    <content type="html"><![CDATA[<p><del>这题难道没人用平板电视（<code>pb_ds</code>）吗</del><br>思路：<del>没思路</del><br>就是用系统自带的<code>pb_ds</code>库，然后就没有然后了。<br>代码如下：  <a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/trie_policy.hpp&gt; // pb_ds头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds; <span class="comment">// pb_ds名称空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> trie&lt;<span class="built_in">string</span>, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; Trie;</span><br><span class="line">Trie tr[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> siz;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; siz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; siz; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            tr[i].insert(tmp); <span class="comment">// 插入到字典树中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (tr[i].find(tmp) != tr[i].end()) <span class="comment">// 如果找到，就输出</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很简单吧！<br>最后，如果要在NOIP中使用pb_ds库，切记不能加<code>using namespace __gnu_pbds;</code>，需要在用到的时候加上<code>__gnu_pbds::</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;这题难道没人用平板电视（&lt;code&gt;pb_ds&lt;/code&gt;）吗&lt;/del&gt;&lt;br&gt;思路：&lt;del&gt;没思路&lt;/del&gt;&lt;br&gt;就是用系统自带的&lt;code&gt;pb_ds&lt;/code&gt;库，然后就没有然后了。&lt;br&gt;代码如下：
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://gandyli.xyz/tags/Luogu/"/>
    
      <category term="TJOI" scheme="https://gandyli.xyz/tags/TJOI/"/>
    
      <category term="2010" scheme="https://gandyli.xyz/tags/2010/"/>
    
  </entry>
  
  <entry>
    <title>题解 Luogu P1689 【方程求解】</title>
    <link href="https://gandyli.xyz/archives/%E9%A2%98%E8%A7%A3-Luogu-P1689-%E3%80%90%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3%E3%80%91/"/>
    <id>https://gandyli.xyz/archives/题解-Luogu-P1689-【方程求解】/</id>
    <published>2018-12-22T04:10:42.000Z</published>
    <updated>2018-12-26T13:24:45.131Z</updated>
    
    <content type="html"><![CDATA[<p>这一题基本思路就是模拟，如果想出来了几乎没什么难度。字符串用<code>C++</code>自带的<code>string类</code>就可以，非常方便。注意题目说可能有多余的空格，因此在输入后还要再转换到一个新的字符串里面。</p><p>代码中我多次用到了一个函数<code>stoi</code>，从<code>C++11</code>才支持，因此在竞赛中不可以使用。我在这里自己写了一个<code>stoi2</code>，供大家参考。<a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi2</span><span class="params">(<span class="built_in">string</span> str)</span> <span class="comment">// 支持负数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">        f = <span class="number">-1</span>, str = str.substr(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (str[i] ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>其实就是快读</del>  </p><hr><p>主程序代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi2</span><span class="params">(<span class="built_in">string</span> str)</span> <span class="comment">// 支持负数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">        f = <span class="number">-1</span>, str = str.substr(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (str[i] ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    getline(<span class="built_in">cin</span>, str);</span><br><span class="line">    <span class="built_in">string</span> newstr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : str)</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">' '</span>)</span><br><span class="line">            newstr.push_back(c);</span><br><span class="line">    <span class="keyword">size_t</span> posq = newstr.find(<span class="string">'?'</span>), posp = newstr.find(<span class="string">'+'</span>), posj = newstr.find(<span class="string">'-'</span>), pose = newstr.find(<span class="string">'='</span>);</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (posq &gt; pose)</span><br><span class="line">        <span class="keyword">if</span> (posp != <span class="built_in">string</span>::npos)</span><br><span class="line">            ans = stoi(newstr.substr(<span class="number">0</span>, posp)) + stoi(<span class="built_in">string</span>(newstr.begin() + posp + <span class="number">1</span>, newstr.begin() + pose));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = stoi(newstr.substr(<span class="number">0</span>, posj)) - stoi(<span class="built_in">string</span>(newstr.begin() + posj + <span class="number">1</span>, newstr.begin() + pose));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (posp != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="keyword">if</span> (posp &gt; posq)</span><br><span class="line">            ans = stoi(newstr.substr(pose + <span class="number">1</span>)) - stoi(<span class="built_in">string</span>(newstr.begin() + posp + <span class="number">1</span>, newstr.begin() + pose));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = stoi(newstr.substr(pose + <span class="number">1</span>)) - stoi(newstr.substr(<span class="number">0</span>, posp));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (posj &gt; posq)</span><br><span class="line">            ans = stoi(<span class="built_in">string</span>(newstr.begin() + posj + <span class="number">1</span>, newstr.begin() + pose)) + stoi(newstr.substr(pose + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = stoi(newstr.substr(<span class="number">0</span>, posj)) - stoi(newstr.substr(pose + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来可能有点乱，但是如果你仔细分析这些句子的意思，就能明白其中的意思。（<del>怎么跟语文一样QAQ</del>）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一题基本思路就是模拟，如果想出来了几乎没什么难度。字符串用&lt;code&gt;C++&lt;/code&gt;自带的&lt;code&gt;string类&lt;/code&gt;就可以，非常方便。注意题目说可能有多余的空格，因此在输入后还要再转换到一个新的字符串里面。&lt;/p&gt;
&lt;p&gt;代码中我多次用到了一个函数&lt;code&gt;stoi&lt;/code&gt;，从&lt;code&gt;C++11&lt;/code&gt;才支持，因此在竞赛中不可以使用。我在这里自己写了一个&lt;code&gt;stoi2&lt;/code&gt;，供大家参考。
    
    </summary>
    
      <category term="题解" scheme="https://gandyli.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://gandyli.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://gandyli.xyz/tags/Luogu/"/>
    
  </entry>
  
</feed>
